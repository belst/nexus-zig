// THIS FILE HAS BEEN AUTO-GENERATED BY THE 'DEAR BINDINGS' GENERATOR.
// **DO NOT EDIT DIRECTLY**
// https://github.com/dearimgui/dear_bindings

// dear imgui, v1.80
struct ImVector_ImDrawListPtr_t { int Size; int Capacity; ImDrawList** Data; };  // Instantiation of ImVector<ImDrawList*>
// (internal structures/api)

// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!
// Set:
//   #define IMGUI_DEFINE_MATH_OPERATORS
// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)

/*

Index of this file:

// [SECTION] Header mess
// [SECTION] Forward declarations
// [SECTION] Context pointer
// [SECTION] STB libraries includes
// [SECTION] Macros
// [SECTION] Generic helpers
// [SECTION] ImDrawList support
// [SECTION] Widgets support: flags, enums, data structures
// [SECTION] Columns support
// [SECTION] Multi-select support
// [SECTION] Docking support
// [SECTION] Viewport support
// [SECTION] Settings support
// [SECTION] Metrics, Debug
// [SECTION] Generic context hooks
// [SECTION] ImGuiContext (main imgui context)
// [SECTION] ImGuiWindowTempData, ImGuiWindow
// [SECTION] Tab bar, Tab item support
// [SECTION] Table support
// [SECTION] Internal API
// [SECTION] Test Engine specific hooks (imgui_test_engine)

*/

#pragma once

#ifdef __cplusplus
extern "C"
{
#endif
#ifndef IMGUI_DISABLE
//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

#ifndef IMGUI_VERSION
#error Must include imgui.h before imgui_internal.h
#endif // #ifndef IMGUI_VERSION
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>
// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4251)  // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#endif // #ifdef _MSC_VER
// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#pragma clang diagnostic push
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option"          // warning: unknown warning group 'xxx'
#endif // #if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-pragmas"                 // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wunused-function"                 // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes"              // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
#pragma clang diagnostic ignored "-Wdouble-promotion"
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"   // warning: implicit conversion from 'xxx' to 'float' may lose precision
#else
#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"               // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wclass-memaccess"       // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif // #if defined(__GNUC__)
#endif // #if defined(__clang__)
// Legacy defines
#ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS
#error Use IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
#endif// Renamed in 1.74
#ifdef IMGUI_DISABLE_MATH_FUNCTIONS
#error Use IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#endif// Renamed in 1.74
//-----------------------------------------------------------------------------
// [SECTION] Forward declarations
// Auto-generated forward declarations for C header
typedef struct ImVector_ImDrawListPtr_t ImVector_ImDrawListPtr;
typedef struct ImVec1_t ImVec1;
typedef struct ImVec2ih_t ImVec2ih;
typedef struct ImSpan_ImGuiTableColumn_t ImSpan_ImGuiTableColumn;
typedef struct ImSpan_ImGuiTableColumnIdx_t ImSpan_ImGuiTableColumnIdx;
typedef struct ImSpan_ImGuiTableCellData_t ImSpan_ImGuiTableCellData;
typedef struct ImChunkStream_ImGuiTableSettings_t ImChunkStream_ImGuiTableSettings;
typedef struct ImChunkStream_ImGuiWindowSettings_t ImChunkStream_ImGuiWindowSettings;
typedef struct ImVector_unsigned_char_t ImVector_unsigned_char;
typedef struct ImVector_ImGuiWindowPtr_t ImVector_ImGuiWindowPtr;
typedef struct ImVector_ImGuiTableColumnSortSpecs_t ImVector_ImGuiTableColumnSortSpecs;
typedef struct ImVector_ImGuiTable_t ImVector_ImGuiTable;
typedef struct ImVector_ImGuiTabItem_t ImVector_ImGuiTabItem;
typedef struct ImVector_ImGuiTabBar_t ImVector_ImGuiTabBar;
typedef struct ImVector_ImGuiStyleMod_t ImVector_ImGuiStyleMod;
typedef struct ImVector_ImGuiShrinkWidthItem_t ImVector_ImGuiShrinkWidthItem;
typedef struct ImVector_ImGuiSettingsHandler_t ImVector_ImGuiSettingsHandler;
typedef struct ImVector_ImGuiPtrOrIndex_t ImVector_ImGuiPtrOrIndex;
typedef struct ImVector_ImGuiPopupData_t ImVector_ImGuiPopupData;
typedef struct ImVector_ImGuiOldColumns_t ImVector_ImGuiOldColumns;
typedef struct ImVector_ImGuiOldColumnData_t ImVector_ImGuiOldColumnData;
typedef struct ImVector_ImGuiItemFlags_t ImVector_ImGuiItemFlags;
typedef struct ImVector_ImGuiID_t ImVector_ImGuiID;
typedef struct ImVector_ImGuiGroupData_t ImVector_ImGuiGroupData;
typedef struct ImVector_ImGuiContextHook_t ImVector_ImGuiContextHook;
typedef struct ImVector_ImGuiColorMod_t ImVector_ImGuiColorMod;
typedef struct ImPool_ImGuiTabBar_t ImPool_ImGuiTabBar;
typedef struct ImPool_ImGuiTable_t ImPool_ImGuiTable;
typedef struct ImGuiDataTypeTempStorage_t ImGuiDataTypeTempStorage;
typedef struct ImGuiShrinkWidthItem_t ImGuiShrinkWidthItem;
typedef struct ImGuiPtrOrIndex_t ImGuiPtrOrIndex;
typedef struct ImGuiTableCellData_t ImGuiTableCellData;
typedef struct ImGuiTableColumnSettings_t ImGuiTableColumnSettings;
// Our current column maximum is 64 but we may raise that in the future.
typedef ImS8 ImGuiTableColumnIdx;
//-----------------------------------------------------------------------------

typedef struct ImBitVector_t ImBitVector;                              // Store 1-bit per value
typedef struct ImRect_t ImRect;                                        // An axis-aligned rectangle (2 points)
typedef struct ImDrawDataBuilder_t ImDrawDataBuilder;                  // Helper to build a ImDrawData instance
typedef struct ImDrawListSharedData_t ImDrawListSharedData;            // Data shared between all ImDrawList instances
typedef struct ImGuiColorMod_t ImGuiColorMod;                          // Stacked color modifier, backup of modified data so we can restore it
typedef struct ImGuiContext_t ImGuiContext;                            // Main Dear ImGui context
typedef struct ImGuiContextHook_t ImGuiContextHook;                    // Hook for extensions like ImGuiTestEngine
typedef struct ImGuiDataTypeInfo_t ImGuiDataTypeInfo;                  // Type information associated to a ImGuiDataType enum
typedef struct ImGuiGroupData_t ImGuiGroupData;                        // Stacked storage data for BeginGroup()/EndGroup()
typedef struct ImGuiInputTextState_t ImGuiInputTextState;              // Internal state of the currently focused/edited text input box
typedef struct ImGuiLastItemDataBackup_t ImGuiLastItemDataBackup;      // Backup and restore IsItemHovered() internal data
typedef struct ImGuiMenuColumns_t ImGuiMenuColumns;                    // Simple column measurement, currently used for MenuItem() only
typedef struct ImGuiNavMoveResult_t ImGuiNavMoveResult;                // Result of a gamepad/keyboard directional navigation move query result
typedef struct ImGuiMetricsConfig_t ImGuiMetricsConfig;                // Storage for ShowMetricsWindow() and DebugNodeXXX() functions
typedef struct ImGuiNextWindowData_t ImGuiNextWindowData;              // Storage for SetNextWindow** functions
typedef struct ImGuiNextItemData_t ImGuiNextItemData;                  // Storage for SetNextItem** functions
typedef struct ImGuiOldColumnData_t ImGuiOldColumnData;                // Storage data for a single column for legacy Columns() api
typedef struct ImGuiOldColumns_t ImGuiOldColumns;                      // Storage data for a columns set for legacy Columns() api
typedef struct ImGuiPopupData_t ImGuiPopupData;                        // Storage for current popup stack
typedef struct ImGuiSettingsHandler_t ImGuiSettingsHandler;            // Storage for one type registered in the .ini file
typedef struct ImGuiStackSizes_t ImGuiStackSizes;                      // Storage of stack sizes for debugging/asserting
typedef struct ImGuiStyleMod_t ImGuiStyleMod;                          // Stacked style modifier, backup of modified data so we can restore it
typedef struct ImGuiTabBar_t ImGuiTabBar;                              // Storage for a tab bar
typedef struct ImGuiTabItem_t ImGuiTabItem;                            // Storage for a tab item (within a tab bar)
typedef struct ImGuiTable_t ImGuiTable;                                // Storage for a table
typedef struct ImGuiTableColumn_t ImGuiTableColumn;                    // Storage for one column of a table
typedef struct ImGuiTableSettings_t ImGuiTableSettings;                // Storage for a table .ini settings
typedef struct ImGuiTableColumnsSettings_t ImGuiTableColumnsSettings;  // Storage for a column .ini settings
typedef struct ImGuiWindow_t ImGuiWindow;                              // Storage for one window
typedef struct ImGuiWindowTempData_t ImGuiWindowTempData;              // Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame)
typedef struct ImGuiWindowSettings_t ImGuiWindowSettings;              // Storage for a window .ini settings (we keep one of those even if the actual window wasn't instanced during this session)

// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
typedef int ImGuiLayoutType;           // -> enum ImGuiLayoutType_         // Enum: Horizontal or vertical
typedef int ImGuiItemFlags;            // -> enum ImGuiItemFlags_          // Flags: for PushItemFlag()
typedef int ImGuiItemStatusFlags;      // -> enum ImGuiItemStatusFlags_    // Flags: for DC.LastItemStatusFlags
typedef int ImGuiOldColumnFlags;       // -> enum ImGuiOldColumnFlags_     // Flags: for BeginColumns()
typedef int ImGuiNavHighlightFlags;    // -> enum ImGuiNavHighlightFlags_  // Flags: for RenderNavHighlight()
typedef int ImGuiNavDirSourceFlags;    // -> enum ImGuiNavDirSourceFlags_  // Flags: for GetNavInputAmount2d()
typedef int ImGuiNavMoveFlags;         // -> enum ImGuiNavMoveFlags_       // Flags: for navigation requests
typedef int ImGuiNextItemDataFlags;    // -> enum ImGuiNextItemDataFlags_  // Flags: for SetNextItemXXX() functions
typedef int ImGuiNextWindowDataFlags;  // -> enum ImGuiNextWindowDataFlags_// Flags: for SetNextWindowXXX() functions
typedef int ImGuiSeparatorFlags;       // -> enum ImGuiSeparatorFlags_     // Flags: for SeparatorEx()
typedef int ImGuiTextFlags;            // -> enum ImGuiTextFlags_          // Flags: for TextEx()
typedef int ImGuiTooltipFlags;         // -> enum ImGuiTooltipFlags_       // Flags: for BeginTooltipEx()

typedef void (*ImGuiErrorLogCallback)(void* user_data, const char* fmt, ...);

//-----------------------------------------------------------------------------
// [SECTION] Context pointer
// See implementation of this variable in imgui.cpp for comments and details.
//-----------------------------------------------------------------------------

//-------------------------------------------------------------------------
// [SECTION] STB libraries includes
//-------------------------------------------------------------------------

#undef STB_TEXTEDIT_STRING
#undef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_STRING             ImGuiInputTextState
#define STB_TEXTEDIT_CHARTYPE           ImWchar
#define STB_TEXTEDIT_GETWIDTH_NEWLINE   (-1.0f)
#define STB_TEXTEDIT_UNDOSTATECOUNT     99
#define STB_TEXTEDIT_UNDOCHARCOUNT      999
#include "imstb_textedit.h"

//-----------------------------------------------------------------------------
// [SECTION] Macros
//-----------------------------------------------------------------------------

// Debug Logging
#ifndef IMGUI_DEBUG_LOG
#define IMGUI_DEBUG_LOG(_FMT,...)       printf("[%05d] " _FMT, GImGui->FrameCount, __VA_ARGS__)
#endif // #ifndef IMGUI_DEBUG_LOG
// Debug Logging for selected systems. Remove the '((void)0) //' to enable.
//#define IMGUI_DEBUG_LOG_POPUP         IMGUI_DEBUG_LOG // Enable log
//#define IMGUI_DEBUG_LOG_NAV           IMGUI_DEBUG_LOG // Enable log
#define IMGUI_DEBUG_LOG_POPUP(...)      ((void)0)        // Disable log
#define IMGUI_DEBUG_LOG_NAV(...)        ((void)0)        // Disable log

// Static Asserts
#if (__cplusplus >= 201100)||(defined(_MSVC_LANG)&& _MSVC_LANG >= 201100)
#define IM_STATIC_ASSERT(_COND)         static_assert(_COND, "")
#else
#define IM_STATIC_ASSERT(_COND)         typedef char static_assertion_##__line__[(_COND)?1:-1]
#endif // #if (__cplusplus >= 201100)||(defined(_MSVC_LANG)&& _MSVC_LANG >= 201100)
// "Paranoid" Debug Asserts are meant to only be enabled during specific debugging/work, otherwise would slow down the code too much.
// We currently don't have many of those so the effect is currently negligible, but onward intent to add more aggressive ones in the code.
//#define IMGUI_DEBUG_PARANOID
#ifdef IMGUI_DEBUG_PARANOID
#define IM_ASSERT_PARANOID(_EXPR)       IM_ASSERT(_EXPR)
#else
#define IM_ASSERT_PARANOID(_EXPR)
#endif // #ifdef IMGUI_DEBUG_PARANOID
// Error handling
// Down the line in some frameworks/languages we would like to have a way to redirect those to the programmer and recover from more faults.
#ifndef IM_ASSERT_USER_ERROR
#define IM_ASSERT_USER_ERROR(_EXP,_MSG) IM_ASSERT((_EXP) && _MSG)    // Recoverable User Error
#endif // #ifndef IM_ASSERT_USER_ERROR
// Misc Macros
#define IM_PI                           3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE                      "\r\n"    // Play it nice with Windows users (Update: since 2018-05, Notepad finally appears to support Unix-style carriage returns!)
#else
#define IM_NEWLINE                      "\n"
#endif // #ifdef _WIN32
#define IM_TABSIZE                      (4)
#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))    // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))                // Saturated, always output 0..255
#define IM_FLOOR(_VAL)                  ((float)(int)(_VAL))                                     // ImFloor() is not inlined in MSVC debug builds
#define IM_ROUND(_VAL)                  ((float)(int)((_VAL) + 0.5f))                            //

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif // #ifdef _MSC_VER
// Debug Tools
// Use 'Metrics->Tools->Item Picker' to break into the call-stack of a specific item.
#ifndef IM_DEBUG_BREAK
#if defined(__clang__)
#define IM_DEBUG_BREAK()    __builtin_debugtrap()
#else
#if defined(_MSC_VER)
#define IM_DEBUG_BREAK()    __debugbreak()
#else
#define IM_DEBUG_BREAK()    IM_ASSERT(0)     // It is expected that you define IM_DEBUG_BREAK() into something that will break nicely in a debugger!
#endif // #if defined(_MSC_VER)
#endif // #if defined(__clang__)
#endif// #ifndef IM_DEBUG_BREAK
//-----------------------------------------------------------------------------
// [SECTION] Generic helpers
// Note that the ImXXX helpers functions are lower-level than ImGui functions.
// ImGui functions or the ImGui context are never called/used from other ImXXX functions.
//-----------------------------------------------------------------------------
// - Helpers: Hashing
// - Helpers: Sorting
// - Helpers: Bit manipulation
// - Helpers: String, Formatting
// - Helpers: UTF-8 <> wchar conversions
// - Helpers: ImVec2/ImVec4 operators
// - Helpers: Maths
// - Helpers: Geometry
// - Helper: ImVec1
// - Helper: ImVec2ih
// - Helper: ImRect
// - Helper: ImBitArray
// - Helper: ImBitVector
// - Helper: ImSpan<>, ImSpanAllocator<>
// - Helper: ImPool<>
// - Helper: ImChunkStream<>
//-----------------------------------------------------------------------------

// Helpers: Hashing
CIMGUI_API ImGuiID cImHashData(const void* data, size_t data_size);                                   // Implied seed = 0
CIMGUI_API ImGuiID cImHashDataEx(const void* data, size_t data_size, ImU32 seed /* = 0 */);
CIMGUI_API ImGuiID cImHashStr(const char* data);                                                      // Implied data_size = 0, seed = 0
CIMGUI_API ImGuiID cImHashStrEx(const char* data, size_t data_size /* = 0 */, ImU32 seed /* = 0 */);
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
CIMGUI_API ImGuiID cImHash(const void* data, int size);                          // Implied seed = 0
CIMGUI_API ImGuiID cImHashEx(const void* data, int size, ImU32 seed /* = 0 */);  // [moved to ImHashStr/ImHashData in 1.68]
#endif // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
// Helpers: Sorting
#define ImQsort         qsort

// Helpers: Color Blending
CIMGUI_API ImU32 cImAlphaBlendColors(ImU32 col_a, ImU32 col_b);

// Helpers: Bit manipulation
CIMGUI_API bool cImIsPowerOfTwo(int v);
CIMGUI_API bool cImIsPowerOfTwoImU64(ImU64 v);
CIMGUI_API int  cImUpperPowerOfTwo(int v);

// Helpers: String, Formatting
CIMGUI_API int            cImStricmp(const char* str1, const char* str2);
CIMGUI_API int            cImStrnicmp(const char* str1, const char* str2, size_t count);
CIMGUI_API void           cImStrncpy(char* dst, const char* src, size_t count);
CIMGUI_API char*          cImStrdup(const char* str);
CIMGUI_API char*          cImStrdupcpy(char* dst, size_t* p_dst_size, const char* str);
CIMGUI_API const char*    cImStrchrRange(const char* str_begin, const char* str_end, char c);
CIMGUI_API int            cImStrlenW(const ImWchar* str);
CIMGUI_API const char*    cImStreolRange(const char* str, const char* str_end);                                       // End end-of-line
CIMGUI_API const ImWchar* cImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin);                          // Find beginning-of-line
CIMGUI_API const char*    cImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);
CIMGUI_API void           cImStrTrimBlanks(char* str);
CIMGUI_API const char*    cImStrSkipBlank(const char* str);
CIMGUI_API int            cImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);
CIMGUI_API int            cImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);
CIMGUI_API const char*    cImParseFormatFindStart(const char* format);
CIMGUI_API const char*    cImParseFormatFindEnd(const char* format);
CIMGUI_API const char*    cImParseFormatTrimDecorations(const char* format, char* buf, size_t buf_size);
CIMGUI_API int            cImParseFormatPrecision(const char* format, int default_value);
CIMGUI_API bool           cImCharIsBlankA(char c);
CIMGUI_API bool           cImCharIsBlankW(unsigned int c);

// Helpers: UTF-8 <> wchar conversions
CIMGUI_API int cImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);  // return output UTF-8 bytes count
CIMGUI_API int cImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);      // read one character. return input UTF-8 bytes count
CIMGUI_API int cImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end);   // Implied in_remaining = NULL
CIMGUI_API int cImTextStrFromUtf8Ex(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining /* = NULL */); // return input UTF-8 bytes count
CIMGUI_API int cImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                        // return number of UTF-8 code-points (NOT bytes count)
CIMGUI_API int cImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end);                    // return number of bytes to express one char in UTF-8
CIMGUI_API int cImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);               // return number of bytes to express string in UTF-8

// Helpers: File System
#ifdef IMGUI_DISABLE_FILE_FUNCTIONS
#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef void* ImFileHandle;
CIMGUI_API ImFileHandle cImFileOpen(const char*, const char*);
CIMGUI_API bool         cImFileClose(ImFileHandle);
CIMGUI_API ImU64        cImFileGetSize(ImFileHandle);
CIMGUI_API ImU64        cImFileRead(void*, ImU64, ImU64, ImFileHandle);
CIMGUI_API ImU64        cImFileWrite(const void*, ImU64, ImU64, ImFileHandle);
#endif // #ifdef IMGUI_DISABLE_FILE_FUNCTIONS
#ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
typedef FILE* ImFileHandle;
CIMGUI_API ImFileHandle cImFileOpen(const char* filename, const char* mode);
CIMGUI_API bool         cImFileClose(ImFileHandle file);
CIMGUI_API ImU64        cImFileGetSize(ImFileHandle file);
CIMGUI_API ImU64        cImFileRead(void* data, ImU64 size, ImU64 count, ImFileHandle file);
CIMGUI_API ImU64        cImFileWrite(const void* data, ImU64 size, ImU64 count, ImFileHandle file);
#else
#define IMGUI_DISABLE_TTY_FUNCTIONS  // Can't use stdout, fflush if we are not using default file functions
#endif // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS
CIMGUI_API void* cImFileLoadToMemory(const char* filename, const char* mode);                                                                     // Implied out_file_size = NULL, padding_bytes = 0
CIMGUI_API void* cImFileLoadToMemoryEx(const char* filename, const char* mode, size_t* out_file_size /* = NULL */, int padding_bytes /* = 0 */);

// Helpers: Maths
// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
#ifndef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
#define ImFabs(X)           fabsf(X)
#define ImSqrt(X)           sqrtf(X)
#define ImFmod(X, Y)        fmodf((X), (Y))
#define ImCos(X)            cosf(X)
#define ImSin(X)            sinf(X)
#define ImAcos(X)           acosf(X)
#define ImAtan2(Y, X)       atan2f((Y), (X))
#define ImAtof(STR)         atof(STR)
#define ImFloorStd(X)       floorf(X)                // We already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by e.g. stb_truetype)
#define ImCeil(X)           ceilf(X)
CIMGUI_API float  cImPow(float x, float y);          // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision
CIMGUI_API double cImPowDouble(double x, double y);
CIMGUI_API float  cImLog(float x);                   // DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision
CIMGUI_API double cImLogDouble(double x);
CIMGUI_API float  cImAbs(float x);
CIMGUI_API double cImAbsDouble(double x);
CIMGUI_API float  cImSign(float x);                  // Sign operator - returns -1, 0 or 1 based on sign of argument
CIMGUI_API double cImSignDouble(double x);
#endif // #ifndef IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS
// - Misc maths helpers
CIMGUI_API ImVec2 cImMin(ImVec2 lhs, ImVec2 rhs);
CIMGUI_API ImVec2 cImMax(ImVec2 lhs, ImVec2 rhs);
CIMGUI_API ImVec2 cImClamp(ImVec2 v, ImVec2 mn, ImVec2 mx);
CIMGUI_API ImVec2 cImLerp(ImVec2 a, ImVec2 b, float t);
CIMGUI_API ImVec2 cImLerpImVec2(ImVec2 a, ImVec2 b, ImVec2 t);
CIMGUI_API ImVec4 cImLerpImVec4(ImVec4 a, ImVec4 b, float t);
CIMGUI_API float  cImSaturate(float f);
CIMGUI_API float  cImLengthSqr(ImVec2 lhs);
CIMGUI_API float  cImLengthSqrImVec4(ImVec4 lhs);
CIMGUI_API float  cImInvLength(ImVec2 lhs, float fail_value);
CIMGUI_API float  cImFloor(float f);
CIMGUI_API ImVec2 cImFloorImVec2(ImVec2 v);
CIMGUI_API int    cImModPositive(int a, int b);
CIMGUI_API float  cImDot(ImVec2 a, ImVec2 b);
CIMGUI_API ImVec2 cImRotate(ImVec2 v, float cos_a, float sin_a);
CIMGUI_API float  cImLinearSweep(float current, float target, float speed);
CIMGUI_API ImVec2 cImMul(ImVec2 lhs, ImVec2 rhs);

// Helpers: Geometry
CIMGUI_API ImVec2   cImBezierCubicCalc(ImVec2 p1, ImVec2 p2, ImVec2 p3, ImVec2 p4, float t);
CIMGUI_API ImVec2   cImBezierCubicClosestPoint(ImVec2 p1, ImVec2 p2, ImVec2 p3, ImVec2 p4, ImVec2 p, int num_segments);              // For curves with explicit number of segments
CIMGUI_API ImVec2   cImBezierCubicClosestPointCasteljau(ImVec2 p1, ImVec2 p2, ImVec2 p3, ImVec2 p4, ImVec2 p, float tess_tol);       // For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol
CIMGUI_API ImVec2   cImBezierQuadraticCalc(ImVec2 p1, ImVec2 p2, ImVec2 p3, float t);
CIMGUI_API ImVec2   cImLineClosestPoint(ImVec2 a, ImVec2 b, ImVec2 p);
CIMGUI_API bool     cImTriangleContainsPoint(ImVec2 a, ImVec2 b, ImVec2 c, ImVec2 p);
CIMGUI_API ImVec2   cImTriangleClosestPoint(ImVec2 a, ImVec2 b, ImVec2 c, ImVec2 p);
CIMGUI_API void     cImTriangleBarycentricCoords(ImVec2 a, ImVec2 b, ImVec2 c, ImVec2 p, float* out_u, float* out_v, float* out_w);
CIMGUI_API float    cImTriangleArea(ImVec2 a, ImVec2 b, ImVec2 c);
CIMGUI_API ImGuiDir cImGetDirQuadrantFromDelta(float dx, float dy);

// Helper: ImVec1 (1D vector)
// (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)
struct ImVec1_t
{
    float x;
};

// Helper: ImVec2ih (2D vector, half-size integer, for long-term packed storage)
struct ImVec2ih_t
{
    short x, y;
};

// Helper: ImRect (2D axis aligned bounding-box)
// NB: we can't rely on ImVec2 math operators being available here!
struct ImRect_t
{
    ImVec2 Min;  // Upper-left
    ImVec2 Max;  // Lower-right
};
CIMGUI_API ImVec2 ImRect_GetCenter(const ImRect* self);
CIMGUI_API ImVec2 ImRect_GetSize(const ImRect* self);
CIMGUI_API float  ImRect_GetWidth(const ImRect* self);
CIMGUI_API float  ImRect_GetHeight(const ImRect* self);
CIMGUI_API ImVec2 ImRect_GetTL(const ImRect* self);                     // Top-left
CIMGUI_API ImVec2 ImRect_GetTR(const ImRect* self);                     // Top-right
CIMGUI_API ImVec2 ImRect_GetBL(const ImRect* self);                     // Bottom-left
CIMGUI_API ImVec2 ImRect_GetBR(const ImRect* self);                     // Bottom-right
CIMGUI_API bool   ImRect_Contains(const ImRect* self, ImVec2 p);
CIMGUI_API bool   ImRect_ContainsImRect(const ImRect* self, ImRect r);
CIMGUI_API bool   ImRect_Overlaps(const ImRect* self, ImRect r);
CIMGUI_API void   ImRect_Add(ImRect* self, ImVec2 p);
CIMGUI_API void   ImRect_AddImRect(ImRect* self, ImRect r);
CIMGUI_API void   ImRect_Expand(ImRect* self, const float amount);
CIMGUI_API void   ImRect_ExpandImVec2(ImRect* self, ImVec2 amount);
CIMGUI_API void   ImRect_Translate(ImRect* self, ImVec2 d);
CIMGUI_API void   ImRect_TranslateX(ImRect* self, float dx);
CIMGUI_API void   ImRect_TranslateY(ImRect* self, float dy);
CIMGUI_API void   ImRect_ClipWith(ImRect* self, ImRect r);              // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
CIMGUI_API void   ImRect_ClipWithFull(ImRect* self, ImRect r);          // Full version, ensure both points are fully clipped.
CIMGUI_API void   ImRect_Floor(ImRect* self);
CIMGUI_API bool   ImRect_IsInverted(const ImRect* self);
CIMGUI_API ImVec4 ImRect_ToVec4(const ImRect* self);

// Helper: ImBitArray
CIMGUI_API bool cImBitArrayTestBit(const ImU32* arr, int n);
CIMGUI_API void cImBitArrayClearBit(ImU32* arr, int n);
CIMGUI_API void cImBitArraySetBit(ImU32* arr, int n);
CIMGUI_API void cImBitArraySetBitRange(ImU32* arr, int n, int n2);  // Works on range [n..n2)

// Helper: ImBitVector
// Store 1-bit per value.
struct ImBitVector_t
{
    ImVector_ImU32 Storage;
};
CIMGUI_API void ImBitVector_Create(ImBitVector* self, int sz);
CIMGUI_API void ImBitVector_Clear(ImBitVector* self);
CIMGUI_API bool ImBitVector_TestBit(const ImBitVector* self, int n);
CIMGUI_API void ImBitVector_SetBit(ImBitVector* self, int n);
CIMGUI_API void ImBitVector_ClearBit(ImBitVector* self, int n);

// Instantiation of ImSpan<ImGuiTableColumn>
struct ImSpan_ImGuiTableColumn_t
{
    ImGuiTableColumn* Data;
    ImGuiTableColumn* DataEnd;
};
// Instantiation of ImSpan<ImGuiTableColumnIdx>
struct ImSpan_ImGuiTableColumnIdx_t
{
    ImGuiTableColumnIdx* Data;
    ImGuiTableColumnIdx* DataEnd;
};
// Instantiation of ImSpan<ImGuiTableCellData>
struct ImSpan_ImGuiTableCellData_t
{
    ImGuiTableCellData* Data;
    ImGuiTableCellData* DataEnd;
};

// Helper: ImPool<>
// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
typedef int ImPoolIdx;

//-----------------------------------------------------------------------------
// [SECTION] ImDrawList support
//-----------------------------------------------------------------------------

// ImDrawList: Helper function to calculate a circle's segment count given its radius and a "maximum error" value.
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN                     12
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX                     512
#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(_RAD,_MAXERROR)    ImClamp((int)((IM_PI * 2.0f) / ImAcos(((_RAD) - (_MAXERROR)) / (_RAD))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)

// ImDrawList: You may set this to higher values (e.g. 2 or 3) to increase tessellation of fast rounded corners path.
#ifndef IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER
#define IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER             1
#endif // #ifndef IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER
// Data shared between all ImDrawList instances
// You may want to create your own instance of this if you want to use ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
struct ImDrawListSharedData_t
{
    ImVec2          TexUvWhitePixel;                                             // UV of white pixel in the atlas
    ImFont*         Font;                                                        // Current/default font (optional, for simplified AddText overload)
    float           FontSize;                                                    // Current/default font size (optional, for simplified AddText overload)
    float           CurveTessellationTol;                                        // Tessellation tolerance when using PathBezierCurveTo()
    float           CircleSegmentMaxError;                                       // Number of circle segments to use per pixel of radius for AddCircle() etc
    ImVec4          ClipRectFullscreen;                                          // Value for PushClipRectFullscreen()
    ImDrawListFlags InitialFlags;                                                // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)

    // [Internal] Lookup tables
    ImVec2          ArcFastVtx[12*IM_DRAWLIST_ARCFAST_TESSELLATION_MULTIPLIER];  // FIXME: Bake rounded corners fill/borders in atlas
    ImU8            CircleSegmentCounts[64];                                     // Precomputed segment count for given radius (array index + 1) before we calculate it dynamically (to avoid calculation overhead)
    const ImVec4*   TexUvLines;                                                  // UV of anti-aliased lines in the atlas
};
CIMGUI_API void ImDrawListSharedData_SetCircleSegmentMaxError(ImDrawListSharedData* self, float max_error);

struct ImDrawDataBuilder_t
{
    ImVector_ImDrawListPtr Layers[2];  // Global layers for: regular, tooltip
};
CIMGUI_API void ImDrawDataBuilder_Clear(ImDrawDataBuilder* self);
CIMGUI_API void ImDrawDataBuilder_ClearFreeMemory(ImDrawDataBuilder* self);
CIMGUI_API void ImDrawDataBuilder_FlattenIntoSingleLayer(ImDrawDataBuilder* self);

//-----------------------------------------------------------------------------
// [SECTION] Widgets support: flags, enums, data structures
// Instantiation of ImChunkStream<ImGuiTableSettings>
struct ImChunkStream_ImGuiTableSettings_t
{
    ImVector_char Buf;
};
// Instantiation of ImChunkStream<ImGuiWindowSettings>
struct ImChunkStream_ImGuiWindowSettings_t
{
    ImVector_char Buf;
};
struct ImVector_unsigned_char_t { int Size; int Capacity; unsigned char* Data; };  // Instantiation of ImVector<unsigned char>
struct ImVector_ImGuiWindowPtr_t { int Size; int Capacity; ImGuiWindow** Data; };  // Instantiation of ImVector<ImGuiWindow*>
struct ImVector_ImGuiTableColumnSortSpecs_t { int Size; int Capacity; ImGuiTableColumnSortSpecs* Data; };  // Instantiation of ImVector<ImGuiTableColumnSortSpecs>
struct ImVector_ImGuiTable_t { int Size; int Capacity; ImGuiTable* Data; };  // Instantiation of ImVector<ImGuiTable>
struct ImVector_ImGuiTabItem_t { int Size; int Capacity; ImGuiTabItem* Data; };  // Instantiation of ImVector<ImGuiTabItem>
struct ImVector_ImGuiTabBar_t { int Size; int Capacity; ImGuiTabBar* Data; };  // Instantiation of ImVector<ImGuiTabBar>
struct ImVector_ImGuiStyleMod_t { int Size; int Capacity; ImGuiStyleMod* Data; };  // Instantiation of ImVector<ImGuiStyleMod>
struct ImVector_ImGuiShrinkWidthItem_t { int Size; int Capacity; ImGuiShrinkWidthItem* Data; };  // Instantiation of ImVector<ImGuiShrinkWidthItem>
struct ImVector_ImGuiSettingsHandler_t { int Size; int Capacity; ImGuiSettingsHandler* Data; };  // Instantiation of ImVector<ImGuiSettingsHandler>
struct ImVector_ImGuiPtrOrIndex_t { int Size; int Capacity; ImGuiPtrOrIndex* Data; };  // Instantiation of ImVector<ImGuiPtrOrIndex>
struct ImVector_ImGuiPopupData_t { int Size; int Capacity; ImGuiPopupData* Data; };  // Instantiation of ImVector<ImGuiPopupData>
struct ImVector_ImGuiOldColumns_t { int Size; int Capacity; ImGuiOldColumns* Data; };  // Instantiation of ImVector<ImGuiOldColumns>
struct ImVector_ImGuiOldColumnData_t { int Size; int Capacity; ImGuiOldColumnData* Data; };  // Instantiation of ImVector<ImGuiOldColumnData>
struct ImVector_ImGuiItemFlags_t { int Size; int Capacity; ImGuiItemFlags* Data; };  // Instantiation of ImVector<ImGuiItemFlags>
struct ImVector_ImGuiID_t { int Size; int Capacity; ImGuiID* Data; };  // Instantiation of ImVector<ImGuiID>
struct ImVector_ImGuiGroupData_t { int Size; int Capacity; ImGuiGroupData* Data; };  // Instantiation of ImVector<ImGuiGroupData>
struct ImVector_ImGuiContextHook_t { int Size; int Capacity; ImGuiContextHook* Data; };  // Instantiation of ImVector<ImGuiContextHook>
struct ImVector_ImGuiColorMod_t { int Size; int Capacity; ImGuiColorMod* Data; };  // Instantiation of ImVector<ImGuiColorMod>
// Instantiation of ImPool<ImGuiTabBar>
struct ImPool_ImGuiTabBar_t
{
    ImVector_ImGuiTabBar Buf;      // Contiguous data
    ImGuiStorage         Map;      // ID->Index
    ImPoolIdx            FreeIdx;  // Next free idx to use
};
// Instantiation of ImPool<ImGuiTable>
struct ImPool_ImGuiTable_t
{
    ImVector_ImGuiTable Buf;      // Contiguous data
    ImGuiStorage        Map;      // ID->Index
    ImPoolIdx           FreeIdx;  // Next free idx to use
};
//-----------------------------------------------------------------------------

// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().
// This is going to be exposed in imgui.h when stabilized enough.
typedef enum
{
    ImGuiItemFlags_None                     = 0,
    ImGuiItemFlags_NoTabStop                = 1<<0,  // false
    ImGuiItemFlags_ButtonRepeat             = 1<<1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
    ImGuiItemFlags_Disabled                 = 1<<2,  // false    // [BETA] Disable interactions but doesn't affect visuals yet. See github.com/ocornut/imgui/issues/211
    ImGuiItemFlags_NoNav                    = 1<<3,  // false
    ImGuiItemFlags_NoNavDefaultFocus        = 1<<4,  // false
    ImGuiItemFlags_SelectableDontClosePopup = 1<<5,  // false    // MenuItem/Selectable() automatically closes current Popup window
    ImGuiItemFlags_MixedValue               = 1<<6,  // false    // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)
    ImGuiItemFlags_ReadOnly                 = 1<<7,  // false    // [ALPHA] Allow hovering interactions but underlying value is not changed.
    ImGuiItemFlags_Default_                 = 0,
} ImGuiItemFlags_;

// Storage for LastItem data
typedef enum
{
    ImGuiItemStatusFlags_None             = 0,
    ImGuiItemStatusFlags_HoveredRect      = 1<<0,
    ImGuiItemStatusFlags_HasDisplayRect   = 1<<1,
    ImGuiItemStatusFlags_Edited           = 1<<2,   // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
    ImGuiItemStatusFlags_ToggledSelection = 1<<3,   // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected" because reporting the change allows us to handle clipping with less issues.
    ImGuiItemStatusFlags_ToggledOpen      = 1<<4,   // Set when TreeNode() reports toggling their open state.
    ImGuiItemStatusFlags_HasDeactivated   = 1<<5,   // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
    ImGuiItemStatusFlags_Deactivated      = 1<<6,   // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.

#ifdef IMGUI_ENABLE_TEST_ENGINE
    ImGuiItemStatusFlags_Openable         = 1<<10,  //
    ImGuiItemStatusFlags_Opened           = 1<<11,  //
    ImGuiItemStatusFlags_Checkable        = 1<<12,  //
    ImGuiItemStatusFlags_Checked          = 1<<13,  //
#endif // #ifdef IMGUI_ENABLE_TEST_ENGINE
} ImGuiItemStatusFlags_;

// Extend ImGuiButtonFlags_
typedef enum
{
    ImGuiButtonFlags_PressedOnClick                = 1<<4,   // return true on click (mouse down event)
    ImGuiButtonFlags_PressedOnClickRelease         = 1<<5,   // [Default] return true on click + release on same item <-- this is what the majority of Button are using
    ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1<<6,   // return true on click + release even if the release event is not done while hovering the item
    ImGuiButtonFlags_PressedOnRelease              = 1<<7,   // return true on release (default requires click+release)
    ImGuiButtonFlags_PressedOnDoubleClick          = 1<<8,   // return true on double-click (default requires click+release)
    ImGuiButtonFlags_PressedOnDragDropHold         = 1<<9,   // return true when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
    ImGuiButtonFlags_Repeat                        = 1<<10,  // hold to repeat
    ImGuiButtonFlags_FlattenChildren               = 1<<11,  // allow interactions even if a child window is overlapping
    ImGuiButtonFlags_AllowItemOverlap              = 1<<12,  // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
    ImGuiButtonFlags_DontClosePopups               = 1<<13,  // disable automatically closing parent popup on press // [UNUSED]
    ImGuiButtonFlags_Disabled                      = 1<<14,  // disable interactions
    ImGuiButtonFlags_AlignTextBaseLine             = 1<<15,  // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
    ImGuiButtonFlags_NoKeyModifiers                = 1<<16,  // disable mouse interaction if a key modifier is held
    ImGuiButtonFlags_NoHoldingActiveId             = 1<<17,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
    ImGuiButtonFlags_NoNavFocus                    = 1<<18,  // don't override navigation focus when activated
    ImGuiButtonFlags_NoHoveredOnFocus              = 1<<19,  // don't report as hovered when nav focus is on this item
    ImGuiButtonFlags_PressedOnMask_                = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,
    ImGuiButtonFlags_PressedOnDefault_             = ImGuiButtonFlags_PressedOnClickRelease,
} ImGuiButtonFlagsPrivate_;

// Extend ImGuiSliderFlags_
typedef enum
{
    ImGuiSliderFlags_Vertical = 1<<20,  // Should this slider be orientated vertically?
    ImGuiSliderFlags_ReadOnly = 1<<21,
} ImGuiSliderFlagsPrivate_;

// Extend ImGuiSelectableFlags_
typedef enum
{
    // NB: need to be in sync with last value of ImGuiSelectableFlags_
    ImGuiSelectableFlags_NoHoldingActiveID    = 1<<20,
    ImGuiSelectableFlags_SelectOnClick        = 1<<21,  // Override button behavior to react on Click (default is Click+Release)
    ImGuiSelectableFlags_SelectOnRelease      = 1<<22,  // Override button behavior to react on Release (default is Click+Release)
    ImGuiSelectableFlags_SpanAvailWidth       = 1<<23,  // Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251d379, 2bcafc86 for menus)
    ImGuiSelectableFlags_DrawHoveredWhenHeld  = 1<<24,  // Always show active when held, even is not hovered. This concept could probably be renamed/formalized somehow.
    ImGuiSelectableFlags_SetNavIdOnHover      = 1<<25,  // Set Nav/Focus ID on mouse hover (used by MenuItem)
    ImGuiSelectableFlags_NoPadWithHalfSpacing = 1<<26,  // Disable padding each side with ItemSpacing * 0.5f
} ImGuiSelectableFlagsPrivate_;

// Extend ImGuiTreeNodeFlags_
typedef enum
{
    ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1<<20,
} ImGuiTreeNodeFlagsPrivate_;

typedef enum
{
    ImGuiSeparatorFlags_None           = 0,
    ImGuiSeparatorFlags_Horizontal     = 1<<0,  // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
    ImGuiSeparatorFlags_Vertical       = 1<<1,
    ImGuiSeparatorFlags_SpanAllColumns = 1<<2,
} ImGuiSeparatorFlags_;

typedef enum
{
    ImGuiTextFlags_None                       = 0,
    ImGuiTextFlags_NoWidthForLargeClippedText = 1<<0,
} ImGuiTextFlags_;

typedef enum
{
    ImGuiTooltipFlags_None                    = 0,
    ImGuiTooltipFlags_OverridePreviousTooltip = 1<<0,  // Override will clear/ignore previously submitted tooltip (defaults to append)
} ImGuiTooltipFlags_;

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
typedef enum
{
    ImGuiLayoutType_Horizontal = 0,
    ImGuiLayoutType_Vertical   = 1,
} ImGuiLayoutType_;

typedef enum
{
    ImGuiLogType_None      = 0,
    ImGuiLogType_TTY,
    ImGuiLogType_File,
    ImGuiLogType_Buffer,
    ImGuiLogType_Clipboard,
} ImGuiLogType;

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
typedef enum
{
    ImGuiAxis_None = -1,
    ImGuiAxis_X    = 0,
    ImGuiAxis_Y    = 1,
} ImGuiAxis;

typedef enum
{
    ImGuiPlotType_Lines,
    ImGuiPlotType_Histogram,
} ImGuiPlotType;

typedef enum
{
    ImGuiInputSource_None        = 0,
    ImGuiInputSource_Mouse,
    ImGuiInputSource_Nav,
    ImGuiInputSource_NavKeyboard,  // Only used occasionally for storage, not tested/handled by most code
    ImGuiInputSource_NavGamepad,   // "
    ImGuiInputSource_COUNT,
} ImGuiInputSource;

// FIXME-NAV: Clarify/expose various repeat delay/rate
typedef enum
{
    ImGuiInputReadMode_Down,
    ImGuiInputReadMode_Pressed,
    ImGuiInputReadMode_Released,
    ImGuiInputReadMode_Repeat,
    ImGuiInputReadMode_RepeatSlow,
    ImGuiInputReadMode_RepeatFast,
} ImGuiInputReadMode;

typedef enum
{
    ImGuiNavHighlightFlags_None        = 0,
    ImGuiNavHighlightFlags_TypeDefault = 1<<0,
    ImGuiNavHighlightFlags_TypeThin    = 1<<1,
    ImGuiNavHighlightFlags_AlwaysDraw  = 1<<2,  // Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.
    ImGuiNavHighlightFlags_NoRounding  = 1<<3,
} ImGuiNavHighlightFlags_;

typedef enum
{
    ImGuiNavDirSourceFlags_None      = 0,
    ImGuiNavDirSourceFlags_Keyboard  = 1<<0,
    ImGuiNavDirSourceFlags_PadDPad   = 1<<1,
    ImGuiNavDirSourceFlags_PadLStick = 1<<2,
} ImGuiNavDirSourceFlags_;

typedef enum
{
    ImGuiNavMoveFlags_None                = 0,
    ImGuiNavMoveFlags_LoopX               = 1<<0,  // On failed request, restart from opposite side
    ImGuiNavMoveFlags_LoopY               = 1<<1,
    ImGuiNavMoveFlags_WrapX               = 1<<2,  // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
    ImGuiNavMoveFlags_WrapY               = 1<<3,  // This is not super useful for provided for completeness
    ImGuiNavMoveFlags_AllowCurrentNavId   = 1<<4,  // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
    ImGuiNavMoveFlags_AlsoScoreVisibleSet = 1<<5,  // Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.
    ImGuiNavMoveFlags_ScrollToEdge        = 1<<6,
} ImGuiNavMoveFlags_;

typedef enum
{
    ImGuiNavForward_None,
    ImGuiNavForward_ForwardQueued,
    ImGuiNavForward_ForwardActive,
} ImGuiNavForward;

typedef enum
{
    ImGuiNavLayer_Main  = 0,  // Main scrolling layer
    ImGuiNavLayer_Menu  = 1,  // Menu layer (access with Alt/ImGuiNavInput_Menu)
    ImGuiNavLayer_COUNT,
} ImGuiNavLayer;

typedef enum
{
    ImGuiPopupPositionPolicy_Default,
    ImGuiPopupPositionPolicy_ComboBox,
    ImGuiPopupPositionPolicy_Tooltip,
} ImGuiPopupPositionPolicy;

struct ImGuiDataTypeTempStorage_t
{
    ImU8 Data[8];  // Can fit any data up to ImGuiDataType_COUNT
};

// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
struct ImGuiDataTypeInfo_t
{
    size_t      Size;      // Size in bytes
    const char* Name;      // Short descriptive name for the type, for debugging
    const char* PrintFmt;  // Default printf format for the type
    const char* ScanFmt;   // Default scanf format for the type
};

// Extend ImGuiDataType_
typedef enum
{
    ImGuiDataType_String  = ImGuiDataType_COUNT+1,
    ImGuiDataType_Pointer,
    ImGuiDataType_ID,
} ImGuiDataTypePrivate_;

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColorMod_t
{
    ImGuiCol Col;
    ImVec4   BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod_t
{
    ImGuiStyleVar VarIdx;
    union
    {
        int   BackupInt[2];
        float BackupFloat[2];
    };
};

// Stacked storage data for BeginGroup()/EndGroup()
struct ImGuiGroupData_t
{
    ImGuiID WindowID;
    ImVec2  BackupCursorPos;
    ImVec2  BackupCursorMaxPos;
    ImVec1  BackupIndent;
    ImVec1  BackupGroupOffset;
    ImVec2  BackupCurrLineSize;
    float   BackupCurrLineTextBaseOffset;
    ImGuiID BackupActiveIdIsAlive;
    bool    BackupActiveIdPreviousFrameIsAlive;
    bool    EmitItem;
};

// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
struct ImGuiMenuColumns_t
{
    float Spacing;
    float Width, NextWidth;
    float Pos[3], NextWidths[3];
};
CIMGUI_API void  ImGuiMenuColumns_Update(ImGuiMenuColumns* self, int count, float spacing, bool clear);
CIMGUI_API float ImGuiMenuColumns_DeclColumns(ImGuiMenuColumns* self, float w0, float w1, float w2);
CIMGUI_API float ImGuiMenuColumns_CalcExtraSpace(const ImGuiMenuColumns* self, float avail_w);

// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
struct ImGuiInputTextState_t
{
    ImGuiID                  ID;                    // widget id owning the text state
    int                      CurLenW, CurLenA;      // we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.
    ImVector_ImWchar         TextW;                 // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
    ImVector_char            TextA;                 // temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.
    ImVector_char            InitialTextA;          // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
    bool                     TextAIsValid;          // temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)
    int                      BufCapacityA;          // end-user buffer capacity
    float                    ScrollX;               // horizontal scrolling/offset
    void*                    Stb;                   // state for stb_textedit.h
    float                    CursorAnim;            // timer for cursor blink, reset on every user action so the cursor reappears immediately
    bool                     CursorFollow;          // set when we want scrolling to follow the current cursor position (not always!)
    bool                     SelectedAllMouseLock;  // after a double-click to select all, we ignore further mouse drags to update selection
    bool                     Edited;                // edited this frame
    ImGuiInputTextFlags      UserFlags;             // Temporarily set while we call user's callback
    ImGuiInputTextCallback   UserCallback;          // "
    void*                    UserCallbackData;      // "
};
CIMGUI_API void ImGuiInputTextState_ClearText(ImGuiInputTextState* self);
CIMGUI_API void ImGuiInputTextState_ClearFreeMemory(ImGuiInputTextState* self);
CIMGUI_API int  ImGuiInputTextState_GetUndoAvailCount(const ImGuiInputTextState* self);
CIMGUI_API int  ImGuiInputTextState_GetRedoAvailCount(const ImGuiInputTextState* self);
CIMGUI_API void ImGuiInputTextState_OnKeyPressed(ImGuiInputTextState* self, int key);  // Cannot be inline because we call in code in stb_textedit.h implementation
// Cursor & Selection
CIMGUI_API void ImGuiInputTextState_CursorAnimReset(ImGuiInputTextState* self);        // After a user-input the cursor stays on for a while without blinking
CIMGUI_API void ImGuiInputTextState_CursorClamp(ImGuiInputTextState* self);
CIMGUI_API bool ImGuiInputTextState_HasSelection(const ImGuiInputTextState* self);
CIMGUI_API void ImGuiInputTextState_ClearSelection(ImGuiInputTextState* self);
CIMGUI_API void ImGuiInputTextState_SelectAll(ImGuiInputTextState* self);

// Storage for current popup stack
struct ImGuiPopupData_t
{
    ImGuiID      PopupId;         // Set on OpenPopup()
    ImGuiWindow* Window;          // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
    ImGuiWindow* SourceWindow;    // Set on OpenPopup() copy of NavWindow at the time of opening the popup
    int          OpenFrameCount;  // Set on OpenPopup()
    ImGuiID      OpenParentId;    // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
    ImVec2       OpenPopupPos;    // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
    ImVec2       OpenMousePos;    // Set on OpenPopup(), copy of mouse position at the time of opening popup
};

struct ImGuiNavMoveResult_t
{
    ImGuiWindow* Window;        // Best candidate window
    ImGuiID      ID;            // Best candidate ID
    ImGuiID      FocusScopeId;  // Best candidate focus scope ID
    float        DistBox;       // Best candidate box distance to current NavId
    float        DistCenter;    // Best candidate center distance to current NavId
    float        DistAxial;
    ImRect       RectRel;       // Best candidate bounding box in window relative space
};
CIMGUI_API void ImGuiNavMoveResult_Clear(ImGuiNavMoveResult* self);

typedef enum
{
    ImGuiNextWindowDataFlags_None              = 0,
    ImGuiNextWindowDataFlags_HasPos            = 1<<0,
    ImGuiNextWindowDataFlags_HasSize           = 1<<1,
    ImGuiNextWindowDataFlags_HasContentSize    = 1<<2,
    ImGuiNextWindowDataFlags_HasCollapsed      = 1<<3,
    ImGuiNextWindowDataFlags_HasSizeConstraint = 1<<4,
    ImGuiNextWindowDataFlags_HasFocus          = 1<<5,
    ImGuiNextWindowDataFlags_HasBgAlpha        = 1<<6,
    ImGuiNextWindowDataFlags_HasScroll         = 1<<7,
} ImGuiNextWindowDataFlags_;

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData_t
{
    ImGuiNextWindowDataFlags Flags;
    ImGuiCond                PosCond;
    ImGuiCond                SizeCond;
    ImGuiCond                CollapsedCond;
    ImVec2                   PosVal;
    ImVec2                   PosPivotVal;
    ImVec2                   SizeVal;
    ImVec2                   ContentSizeVal;
    ImVec2                   ScrollVal;
    bool                     CollapsedVal;
    ImRect                   SizeConstraintRect;
    ImGuiSizeCallback        SizeCallback;
    void*                    SizeCallbackUserData;
    float                    BgAlphaVal;           // Override background alpha
    ImVec2                   MenuBarOffsetMinVal;  // *Always on* This is not exposed publicly, so we don't clear it.
};
CIMGUI_API void ImGuiNextWindowData_ClearFlags(ImGuiNextWindowData* self);

typedef enum
{
    ImGuiNextItemDataFlags_None     = 0,
    ImGuiNextItemDataFlags_HasWidth = 1<<0,
    ImGuiNextItemDataFlags_HasOpen  = 1<<1,
} ImGuiNextItemDataFlags_;

struct ImGuiNextItemData_t
{
    ImGuiNextItemDataFlags Flags;
    float                  Width;         // Set by SetNextItemWidth()
    ImGuiID                FocusScopeId;  // Set by SetNextItemMultiSelectData() (!= 0 signify value has been set, so it's an alternate version of HasSelectionData, we don't use Flags for this because they are cleared too early. This is mostly used for debugging)
    ImGuiCond              OpenCond;
    bool                   OpenVal;       // Set by SetNextItemOpen()
};
CIMGUI_API void ImGuiNextItemData_ClearFlags(ImGuiNextItemData* self);  // Also cleared manually by ItemAdd()!

struct ImGuiShrinkWidthItem_t
{
    int   Index;
    float Width;
};

struct ImGuiPtrOrIndex_t
{
    void* Ptr;    // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
    int   Index;  // Usually index in a main pool.
};

//-----------------------------------------------------------------------------
// [SECTION] Columns support
//-----------------------------------------------------------------------------

// Flags for internal's BeginColumns(). Prefix using BeginTable() nowadays!
typedef enum
{
    ImGuiOldColumnFlags_None                   = 0,
    ImGuiOldColumnFlags_NoBorder               = 1<<0,  // Disable column dividers
    ImGuiOldColumnFlags_NoResize               = 1<<1,  // Disable resizing columns when clicking on the dividers
    ImGuiOldColumnFlags_NoPreserveWidths       = 1<<2,  // Disable column width preservation when adjusting columns
    ImGuiOldColumnFlags_NoForceWithinWindow    = 1<<3,  // Disable forcing columns to fit within window
    ImGuiOldColumnFlags_GrowParentContentsSize = 1<<4,  // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.

    // Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    ImGuiColumnsFlags_None                     = ImGuiOldColumnFlags_None,
    ImGuiColumnsFlags_NoBorder                 = ImGuiOldColumnFlags_NoBorder,
    ImGuiColumnsFlags_NoResize                 = ImGuiOldColumnFlags_NoResize,
    ImGuiColumnsFlags_NoPreserveWidths         = ImGuiOldColumnFlags_NoPreserveWidths,
    ImGuiColumnsFlags_NoForceWithinWindow      = ImGuiOldColumnFlags_NoForceWithinWindow,
    ImGuiColumnsFlags_GrowParentContentsSize   = ImGuiOldColumnFlags_GrowParentContentsSize,
#endif // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
} ImGuiOldColumnFlags_;

struct ImGuiOldColumnData_t
{
    float               OffsetNorm;  // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
    float               OffsetNormBeforeResize;
    ImGuiOldColumnFlags Flags;       // Not exposed
    ImRect              ClipRect;
};

struct ImGuiOldColumns_t
{
    ImGuiID                     ID;
    ImGuiOldColumnFlags         Flags;
    bool                        IsFirstFrame;
    bool                        IsBeingResized;
    int                         Current;
    int                         Count;
    float                       OffMinX, OffMaxX;          // Offsets from HostWorkRect.Min.x
    float                       LineMinY, LineMaxY;
    float                       HostCursorPosY;            // Backup of CursorPos at the time of BeginColumns()
    float                       HostCursorMaxPosX;         // Backup of CursorMaxPos at the time of BeginColumns()
    ImRect                      HostInitialClipRect;       // Backup of ClipRect at the time of BeginColumns()
    ImRect                      HostBackupClipRect;        // Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()
    ImRect                      HostBackupParentWorkRect;  //Backup of WorkRect at the time of BeginColumns()
    ImVector_ImGuiOldColumnData Columns;
    ImDrawListSplitter          Splitter;
};

//-----------------------------------------------------------------------------
// [SECTION] Multi-select support
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Docking support
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Viewport support
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Settings support
//-----------------------------------------------------------------------------

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
struct ImGuiWindowSettings_t
{
    ImGuiID  ID;
    ImVec2ih Pos;
    ImVec2ih Size;
    bool     Collapsed;
    bool     WantApply;  // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
};
CIMGUI_API char* ImGuiWindowSettings_GetName(ImGuiWindowSettings* self);

struct ImGuiSettingsHandler_t
{
    const char*                                                          TypeName;                        // Short description stored in .ini file. Disallowed characters: '[' ']'
    ImGuiID                                                              TypeHash;                        // == ImHashStr(TypeName)
    void (*ClearAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                 // Clear all settings data
    void (*ReadInitFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                 // Read: Called before reading (in registration order)
    void* (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
    void (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line);  // Read: Called for every line of text within an ini entry
    void (*ApplyAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                 // Read: Called after reading (in registration order)
    void (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);       // Write: Output every entries into 'out_buf'
    void*                                                                UserData;
};

//-----------------------------------------------------------------------------
// [SECTION] Metrics, Debug
//-----------------------------------------------------------------------------

struct ImGuiMetricsConfig_t
{
    bool ShowWindowsRects;
    bool ShowWindowsBeginOrder;
    bool ShowTablesRects;
    bool ShowDrawCmdMesh;
    bool ShowDrawCmdBoundingBoxes;
    int  ShowWindowsRectsType;
    int  ShowTablesRectsType;
};

struct ImGuiStackSizes_t
{
    short SizeOfIDStack;
    short SizeOfColorStack;
    short SizeOfStyleVarStack;
    short SizeOfFontStack;
    short SizeOfFocusScopeStack;
    short SizeOfGroupStack;
    short SizeOfBeginPopupStack;
};
CIMGUI_API void ImGuiStackSizes_SetToCurrentState(ImGuiStackSizes* self);
CIMGUI_API void ImGuiStackSizes_CompareWithCurrentState(ImGuiStackSizes* self);

//-----------------------------------------------------------------------------
// [SECTION] Generic context hooks
//-----------------------------------------------------------------------------

typedef void (*ImGuiContextHookCallback)(ImGuiContext* ctx, ImGuiContextHook* hook);
typedef enum
{
    ImGuiContextHookType_NewFramePre,
    ImGuiContextHookType_NewFramePost,
    ImGuiContextHookType_EndFramePre,
    ImGuiContextHookType_EndFramePost,
    ImGuiContextHookType_RenderPre,
    ImGuiContextHookType_RenderPost,
    ImGuiContextHookType_Shutdown,
} ImGuiContextHookType;

struct ImGuiContextHook_t
{
    ImGuiContextHookType     Type;
    ImGuiID                  Owner;
    ImGuiContextHookCallback Callback;
    void*                    UserData;
};

//-----------------------------------------------------------------------------
// [SECTION] ImGuiContext (main imgui context)
//-----------------------------------------------------------------------------

struct ImGuiContext_t
{
    bool                          Initialized;
    bool                          FontAtlasOwnedByContext;             // IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
    ImGuiIO                       IO;
    ImGuiStyle                    Style;
    ImFont*                       Font;                                // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
    float                         FontSize;                            // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
    float                         FontBaseSize;                        // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
    ImDrawListSharedData          DrawListSharedData;
    double                        Time;
    int                           FrameCount;
    int                           FrameCountEnded;
    int                           FrameCountRendered;
    bool                          WithinFrameScope;                    // Set by NewFrame(), cleared by EndFrame()
    bool                          WithinFrameScopeWithImplicitWindow;  // Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
    bool                          WithinEndChild;                      // Set within EndChild()
    bool                          GcCompactAll;                        // Request full GC
    bool                          TestEngineHookItems;                 // Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()
    ImGuiID                       TestEngineHookIdInfo;                // Will call test engine hooks: ImGuiTestEngineHook_IdInfo() from GetID()
    void*                         TestEngine;                          // Test engine user data

    // Windows state
    ImVector_ImGuiWindowPtr       Windows;                             // Windows, sorted in display order, back to front
    ImVector_ImGuiWindowPtr       WindowsFocusOrder;                   // Windows, sorted in focus order, back to front. (FIXME: We could only store root windows here! Need to sort out the Docking equivalent which is RootWindowDockStop and is unfortunately a little more dynamic)
    ImVector_ImGuiWindowPtr       WindowsTempSortBuffer;               // Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child
    ImVector_ImGuiWindowPtr       CurrentWindowStack;
    ImGuiStorage                  WindowsById;                         // Map window's ImGuiID to ImGuiWindow*
    int                           WindowsActiveCount;                  // Number of unique windows submitted by frame
    ImGuiWindow*                  CurrentWindow;                       // Window being drawn into
    ImGuiWindow*                  HoveredWindow;                       // Window the mouse is hovering. Will typically catch mouse inputs.
    ImGuiWindow*                  HoveredRootWindow;                   // == HoveredWindow ? HoveredWindow->RootWindow : NULL, merely a shortcut to avoid null test in some situation.
    ImGuiWindow*                  HoveredWindowUnderMovingWindow;      // Hovered window ignoring MovingWindow. Only set if MovingWindow is set.
    ImGuiWindow*                  MovingWindow;                        // Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindow.
    ImGuiWindow*                  WheelingWindow;                      // Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
    ImVec2                        WheelingWindowRefMousePos;
    float                         WheelingWindowTimer;

    // Item/widgets state and tracking information
    ImGuiID                       HoveredId;                           // Hovered widget, filled during the frame
    ImGuiID                       HoveredIdPreviousFrame;
    bool                          HoveredIdAllowOverlap;
    bool                          HoveredIdUsingMouseWheel;            // Hovered widget will use mouse wheel. Blocks scrolling the underlying window.
    bool                          HoveredIdPreviousFrameUsingMouseWheel;
    bool                          HoveredIdDisabled;                   // At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.
    float                         HoveredIdTimer;                      // Measure contiguous hovering time
    float                         HoveredIdNotActiveTimer;             // Measure contiguous hovering time where the item has not been active
    ImGuiID                       ActiveId;                            // Active widget
    ImGuiID                       ActiveIdIsAlive;                     // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
    float                         ActiveIdTimer;
    bool                          ActiveIdIsJustActivated;             // Set at the time of activation for one frame
    bool                          ActiveIdAllowOverlap;                // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
    bool                          ActiveIdNoClearOnFocusLoss;          // Disable losing active id if the active id window gets unfocused.
    bool                          ActiveIdHasBeenPressedBefore;        // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
    bool                          ActiveIdHasBeenEditedBefore;         // Was the value associated to the widget Edited over the course of the Active state.
    bool                          ActiveIdHasBeenEditedThisFrame;
    bool                          ActiveIdUsingMouseWheel;             // Active widget will want to read mouse wheel. Blocks scrolling the underlying window.
    ImU32                         ActiveIdUsingNavDirMask;             // Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)
    ImU32                         ActiveIdUsingNavInputMask;           // Active widget will want to read those nav inputs.
    ImU64                         ActiveIdUsingKeyInputMask;           // Active widget will want to read those key inputs. When we grow the ImGuiKey enum we'll need to either to order the enum to make useful keys come first, either redesign this into e.g. a small array.
    ImVec2                        ActiveIdClickOffset;                 // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
    ImGuiWindow*                  ActiveIdWindow;
    ImGuiInputSource              ActiveIdSource;                      // Activating with mouse or nav (gamepad/keyboard)
    int                           ActiveIdMouseButton;
    ImGuiID                       ActiveIdPreviousFrame;
    bool                          ActiveIdPreviousFrameIsAlive;
    bool                          ActiveIdPreviousFrameHasBeenEditedBefore;
    ImGuiWindow*                  ActiveIdPreviousFrameWindow;
    ImGuiID                       LastActiveId;                        // Store the last non-zero ActiveId, useful for animation.
    float                         LastActiveIdTimer;                   // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.

    // Next window/item data
    ImGuiNextWindowData           NextWindowData;                      // Storage for SetNextWindow** functions
    ImGuiNextItemData             NextItemData;                        // Storage for SetNextItem** functions

    // Shared stacks
    ImVector_ImGuiColorMod        ColorStack;                          // Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()
    ImVector_ImGuiStyleMod        StyleVarStack;                       // Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()
    ImVector_ImFontPtr            FontStack;                           // Stack for PushFont()/PopFont() - inherited by Begin()
    ImVector_ImGuiID              FocusScopeStack;                     // Stack for PushFocusScope()/PopFocusScope() - not inherited by Begin(), unless child window
    ImVector_ImGuiItemFlags       ItemFlagsStack;                      // Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()
    ImVector_ImGuiGroupData       GroupStack;                          // Stack for BeginGroup()/EndGroup() - not inherited by Begin()
    ImVector_ImGuiPopupData       OpenPopupStack;                      // Which popups are open (persistent)
    ImVector_ImGuiPopupData       BeginPopupStack;                     // Which level of BeginPopup() we are in (reset every frame)

    // Gamepad/keyboard Navigation
    ImGuiWindow*                  NavWindow;                           // Focused window for navigation. Could be called 'FocusWindow'
    ImGuiID                       NavId;                               // Focused item for navigation
    ImGuiID                       NavFocusScopeId;                     // Identify a selection scope (selection code often wants to "clear other items" when landing on an item of the selection set)
    ImGuiID                       NavActivateId;                       // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()
    ImGuiID                       NavActivateDownId;                   // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                       NavActivatePressedId;                // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0
    ImGuiID                       NavInputId;                          // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0
    ImGuiID                       NavJustTabbedId;                     // Just tabbed to this id.
    ImGuiID                       NavJustMovedToId;                    // Just navigated to this id (result of a successfully MoveRequest).
    ImGuiID                       NavJustMovedToFocusScopeId;          // Just navigated to this focus scope id (result of a successfully MoveRequest).
    ImGuiKeyModFlags              NavJustMovedToKeyMods;
    ImGuiID                       NavNextActivateId;                   // Set by ActivateItem(), queued until next frame.
    ImGuiInputSource              NavInputSource;                      // Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.
    ImRect                        NavScoringRect;                      // Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.
    int                           NavScoringCount;                     // Metrics for debugging
    ImGuiNavLayer                 NavLayer;                            // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.
    int                           NavIdTabCounter;                     // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing
    bool                          NavIdIsAlive;                        // Nav widget has been seen this frame ~~ NavRectRel is valid
    bool                          NavMousePosDirty;                    // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
    bool                          NavDisableHighlight;                 // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
    bool                          NavDisableMouseHover;                // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.
    bool                          NavAnyRequest;                       // ~~ NavMoveRequest || NavInitRequest
    bool                          NavInitRequest;                      // Init request for appearing window to select first item
    bool                          NavInitRequestFromMove;
    ImGuiID                       NavInitResultId;                     // Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)
    ImRect                        NavInitResultRectRel;                // Init request result rectangle (relative to parent window)
    bool                          NavMoveRequest;                      // Move request for this frame
    ImGuiNavMoveFlags             NavMoveRequestFlags;
    ImGuiNavForward               NavMoveRequestForward;               // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)
    ImGuiKeyModFlags              NavMoveRequestKeyMods;
    ImGuiDir                      NavMoveDir, NavMoveDirLast;          // Direction of the move request (left/right/up/down), direction of the previous move request
    ImGuiDir                      NavMoveClipDir;                      // FIXME-NAV: Describe the purpose of this better. Might want to rename?
    ImGuiNavMoveResult            NavMoveResultLocal;                  // Best move request candidate within NavWindow
    ImGuiNavMoveResult            NavMoveResultLocalVisibleSet;        // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
    ImGuiNavMoveResult            NavMoveResultOther;                  // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)
    ImGuiWindow*                  NavWrapRequestWindow;                // Window which requested trying nav wrap-around.
    ImGuiNavMoveFlags             NavWrapRequestFlags;                 // Wrap-around operation flags.

    // Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to move/resize)
    ImGuiWindow*                  NavWindowingTarget;                  // Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!
    ImGuiWindow*                  NavWindowingTargetAnim;              // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.
    ImGuiWindow*                  NavWindowingListWindow;              // Internal window actually listing the CTRL+Tab contents
    float                         NavWindowingTimer;
    float                         NavWindowingHighlightAlpha;
    bool                          NavWindowingToggleLayer;

    // Legacy Focus/Tabbing system (older than Nav, active even if Nav is disabled, misnamed. FIXME-NAV: This needs a redesign!)
    ImGuiWindow*                  FocusRequestCurrWindow;              //
    ImGuiWindow*                  FocusRequestNextWindow;              //
    int                           FocusRequestCurrCounterRegular;      // Any item being requested for focus, stored as an index (we on layout to be stable between the frame pressing TAB and the next frame, semi-ouch)
    int                           FocusRequestCurrCounterTabStop;      // Tab item being requested for focus, stored as an index
    int                           FocusRequestNextCounterRegular;      // Stored for next frame
    int                           FocusRequestNextCounterTabStop;      // "
    bool                          FocusTabPressed;                     //

    // Render
    ImDrawData                    DrawData;                            // Main ImDrawData instance to pass render information to the user
    ImDrawDataBuilder             DrawDataBuilder;
    float                         DimBgRatio;                          // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)
    ImDrawList                    BackgroundDrawList;                  // First draw list to be rendered.
    ImDrawList                    ForegroundDrawList;                  // Last draw list to be rendered. This is where we the render software mouse cursor (if io.MouseDrawCursor is set) and most debug overlays.
    ImGuiMouseCursor              MouseCursor;

    // Drag and Drop
    bool                          DragDropActive;
    bool                          DragDropWithinSource;                // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.
    bool                          DragDropWithinTarget;                // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.
    ImGuiDragDropFlags            DragDropSourceFlags;
    int                           DragDropSourceFrameCount;
    int                           DragDropMouseButton;
    ImGuiPayload                  DragDropPayload;
    ImRect                        DragDropTargetRect;                  // Store rectangle of current target candidate (we favor small targets when overlapping)
    ImGuiID                       DragDropTargetId;
    ImGuiDragDropFlags            DragDropAcceptFlags;
    float                         DragDropAcceptIdCurrRectSurface;     // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
    ImGuiID                       DragDropAcceptIdCurr;                // Target item id (set at the time of accepting the payload)
    ImGuiID                       DragDropAcceptIdPrev;                // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
    int                           DragDropAcceptFrameCount;            // Last time a target expressed a desire to accept the source
    ImGuiID                       DragDropHoldJustPressedId;           // Set when holding a payload just made ButtonBehavior() return a press.
    ImVector_unsigned_char        DragDropPayloadBufHeap;              // We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size
    unsigned char                 DragDropPayloadBufLocal[16];         // Local buffer for small payloads

    // Table
    ImGuiTable*                   CurrentTable;
    ImPool_ImGuiTable             Tables;
    ImVector_ImGuiPtrOrIndex      CurrentTableStack;
    ImVector_float                TablesLastTimeActive;                // Last used timestamp of each tables (SOA, for efficient GC)
    ImVector_ImDrawChannel        DrawChannelsTempMergeBuffer;

    // Tab bars
    ImGuiTabBar*                  CurrentTabBar;
    ImPool_ImGuiTabBar            TabBars;
    ImVector_ImGuiPtrOrIndex      CurrentTabBarStack;
    ImVector_ImGuiShrinkWidthItem ShrinkWidthBuffer;

    // Widget state
    ImVec2                        LastValidMousePos;
    ImGuiInputTextState           InputTextState;
    ImFont                        InputTextPasswordFont;
    ImGuiID                       TempInputId;                         // Temporary text input when CTRL+clicking on a slider, etc.
    ImGuiColorEditFlags           ColorEditOptions;                    // Store user options for color edit widgets
    float                         ColorEditLastHue;                    // Backup of last Hue associated to LastColor[3], so we can restore Hue in lossy RGB<>HSV round trips
    float                         ColorEditLastSat;                    // Backup of last Saturation associated to LastColor[3], so we can restore Saturation in lossy RGB<>HSV round trips
    float                         ColorEditLastColor[3];
    ImVec4                        ColorPickerRef;                      // Initial/reference color at the time of opening the color picker.
    float                         SliderCurrentAccum;                  // Accumulated slider delta when using navigation controls.
    bool                          SliderCurrentAccumDirty;             // Has the accumulated slider delta changed since last time we tried to apply it?
    bool                          DragCurrentAccumDirty;
    float                         DragCurrentAccum;                    // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
    float                         DragSpeedDefaultRatio;               // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
    float                         ScrollbarClickDeltaToGrabCenter;     // Distance between mouse and center of grab box, normalized in parent space. Use storage?
    int                           TooltipOverrideCount;
    float                         TooltipSlowDelay;                    // Time before slow tooltips appears (FIXME: This is temporary until we merge in tooltip timer+priority work)
    ImVector_char                 ClipboardHandlerData;                // If no custom clipboard handler is defined
    ImVector_ImGuiID              MenusIdSubmittedThisFrame;           // A list of menu IDs that were rendered at least once

    // Platform support
    ImVec2                        PlatformImePos;                      // Cursor position request & last passed to the OS Input Method Editor
    ImVec2                        PlatformImeLastPos;
    char                          PlatformLocaleDecimalPoint;          // '.' or *localeconv()->decimal_point

    // Settings
    bool                          SettingsLoaded;
    float                         SettingsDirtyTimer;                  // Save .ini Settings to memory when time reaches zero
    ImGuiTextBuffer               SettingsIniData;                     // In memory .ini settings
    ImVector_ImGuiSettingsHandler SettingsHandlers;                    // List of .ini settings handlers
    ImChunkStream_ImGuiWindowSettings SettingsWindows;                 // ImGuiWindow .ini settings entries
    ImChunkStream_ImGuiTableSettings SettingsTables;                   // ImGuiTable .ini settings entries
    ImVector_ImGuiContextHook     Hooks;                               // Hooks for extensions (e.g. test engine)

    // Capture/Logging
    bool                          LogEnabled;                          // Currently capturing
    ImGuiLogType                  LogType;                             // Capture target
    ImFileHandle                  LogFile;                             // If != NULL log to stdout/ file
    ImGuiTextBuffer               LogBuffer;                           // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
    float                         LogLinePosY;
    bool                          LogLineFirstItem;
    int                           LogDepthRef;
    int                           LogDepthToExpand;
    int                           LogDepthToExpandDefault;             // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.

    // Debug Tools
    bool                          DebugItemPickerActive;               // Item picker is active (started with DebugStartItemPicker())
    ImGuiID                       DebugItemPickerBreakId;              // Will call IM_DEBUG_BREAK() when encountering this id
    ImGuiMetricsConfig            DebugMetricsConfig;

    // Misc
    float                         FramerateSecPerFrame[120];           // Calculate estimate of framerate for user over the last 2 seconds.
    int                           FramerateSecPerFrameIdx;
    float                         FramerateSecPerFrameAccum;
    int                           WantCaptureMouseNextFrame;           // Explicit capture via CaptureKeyboardFromApp()/CaptureMouseFromApp() sets those flags
    int                           WantCaptureKeyboardNextFrame;
    int                           WantTextInputNextFrame;
    char                          TempBuffer[1024*3+1];                // Temporary text buffer
};

//-----------------------------------------------------------------------------
// [SECTION] ImGuiWindowTempData, ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)
// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)
struct ImGuiWindowTempData_t
{
    // Layout
    ImVec2                  CursorPos;                  // Current emitting position, in absolute coordinates.
    ImVec2                  CursorPosPrevLine;
    ImVec2                  CursorStartPos;             // Initial position after Begin(), generally ~ window position + WindowPadding.
    ImVec2                  CursorMaxPos;               // Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.
    ImVec2                  IdealMaxPos;                // Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.
    ImVec2                  CurrLineSize;
    ImVec2                  PrevLineSize;
    float                   CurrLineTextBaseOffset;     // Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
    float                   PrevLineTextBaseOffset;
    ImVec1                  Indent;                     // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
    ImVec1                  ColumnsOffset;              // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
    ImVec1                  GroupOffset;

    // Last item status
    ImGuiID                 LastItemId;                 // ID for last item
    ImGuiItemStatusFlags    LastItemStatusFlags;        // Status flags for last item (see ImGuiItemStatusFlags_)
    ImRect                  LastItemRect;               // Interaction rect for last item
    ImRect                  LastItemDisplayRect;        // End-user display rect for last item (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)

    // Keyboard/Gamepad navigation
    ImGuiNavLayer           NavLayerCurrent;            // Current layer, 0..31 (we currently only use 0..1)
    int                     NavLayerActiveMask;         // Which layers have been written to (result from previous frame)
    int                     NavLayerActiveMaskNext;     // Which layers have been written to (accumulator for current frame)
    ImGuiID                 NavFocusScopeIdCurrent;     // Current focus scope ID while appending
    bool                    NavHideHighlightOneFrame;
    bool                    NavHasScroll;               // Set when scrolling can be used (ScrollMax > 0.0f)

    // Miscellaneous
    bool                    MenuBarAppending;           // FIXME: Remove this
    ImVec2                  MenuBarOffset;              // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
    ImGuiMenuColumns        MenuColumns;                // Simplified columns storage for menu items measurement
    int                     TreeDepth;                  // Current tree depth.
    ImU32                   TreeJumpToParentOnPopMask;  // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.
    ImVector_ImGuiWindowPtr ChildWindows;
    ImGuiStorage*           StateStorage;               // Current persistent per-window storage (store e.g. tree node open/close state)
    ImGuiOldColumns*        CurrentColumns;             // Current columns set
    int                     CurrentTableIdx;            // Current table index (into g.Tables)
    ImGuiLayoutType         LayoutType;
    ImGuiLayoutType         ParentLayoutType;           // Layout type of parent window at the time of Begin()
    int                     FocusCounterRegular;        // (Legacy Focus/Tabbing system) Sequential counter, start at -1 and increase as assigned via FocusableItemRegister() (FIXME-NAV: Needs redesign)
    int                     FocusCounterTabStop;        // (Legacy Focus/Tabbing system) Same, but only count widgets which you can Tab through.

    // Local parameters stacks
    // We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
    ImGuiItemFlags          ItemFlags;                  // == g.ItemFlagsStack.back()
    float                   ItemWidth;                  // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window
    float                   TextWrapPos;                // == TextWrapPosStack.back() [empty == -1.0f]
    ImVector_float          ItemWidthStack;
    ImVector_float          TextWrapPosStack;
    ImGuiStackSizes         StackSizesOnBegin;          // Store size of various stacks for asserting
};

// Storage for one window
struct ImGuiWindow_t
{
    char*                    Name;                              // Window name, owned by the window.
    ImGuiID                  ID;                                // == ImHashStr(Name)
    ImGuiWindowFlags         Flags;                             // See enum ImGuiWindowFlags_
    ImVec2                   Pos;                               // Position (always rounded-up to nearest pixel)
    ImVec2                   Size;                              // Current size (==SizeFull or collapsed title bar size)
    ImVec2                   SizeFull;                          // Size when non collapsed
    ImVec2                   ContentSize;                       // Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
    ImVec2                   ContentSizeIdeal;
    ImVec2                   ContentSizeExplicit;               // Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
    ImVec2                   WindowPadding;                     // Window padding at the time of Begin().
    float                    WindowRounding;                    // Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.
    float                    WindowBorderSize;                  // Window border size at the time of Begin().
    int                      NameBufLen;                        // Size of buffer storing Name. May be larger than strlen(Name)!
    ImGuiID                  MoveId;                            // == window->GetID("#MOVE")
    ImGuiID                  ChildId;                           // ID of corresponding item in parent window (for navigation to return from child window to parent window)
    ImVec2                   Scroll;
    ImVec2                   ScrollMax;
    ImVec2                   ScrollTarget;                      // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
    ImVec2                   ScrollTargetCenterRatio;           // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
    ImVec2                   ScrollTargetEdgeSnapDist;          // 0.0f = no snapping, >0.0f snapping threshold
    ImVec2                   ScrollbarSizes;                    // Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.
    bool                     ScrollbarX, ScrollbarY;            // Are scrollbars visible?
    bool                     Active;                            // Set to true on Begin(), unless Collapsed
    bool                     WasActive;
    bool                     WriteAccessed;                     // Set to true when any widget access the current window
    bool                     Collapsed;                         // Set when collapsing window to become only title-bar
    bool                     WantCollapseToggle;
    bool                     SkipItems;                         // Set when items can safely be all clipped (e.g. window not visible or collapsed)
    bool                     Appearing;                         // Set during the frame where the window is appearing (or re-appearing)
    bool                     Hidden;                            // Do not display (== HiddenFrames*** > 0)
    bool                     IsFallbackWindow;                  // Set on the "Debug##Default" window.
    bool                     HasCloseButton;                    // Set when the window has a close button (p_open != NULL)
    signed char              ResizeBorderHeld;                  // Current border being held for resize (-1: none, otherwise 0-3)
    short                    BeginCount;                        // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
    short                    BeginOrderWithinParent;            // Order within immediate parent window, if we are a child window. Otherwise 0.
    short                    BeginOrderWithinContext;           // Order within entire imgui context. This is mostly used for debugging submission order related issues.
    ImGuiID                  PopupId;                           // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
    ImS8                     AutoFitFramesX, AutoFitFramesY;
    ImS8                     AutoFitChildAxises;
    bool                     AutoFitOnlyGrows;
    ImGuiDir                 AutoPosLastDirection;
    ImS8                     HiddenFramesCanSkipItems;          // Hide the window for N frames
    ImS8                     HiddenFramesCannotSkipItems;       // Hide the window for N frames while allowing items to be submitted so we can measure their size
    ImS8                     HiddenFramesForRenderOnly;         // Hide the window until frame N at Render() time only
    ImGuiCond                SetWindowPosAllowFlags : 8;        // store acceptable condition flags for SetNextWindowPos() use.
    ImGuiCond                SetWindowSizeAllowFlags : 8;       // store acceptable condition flags for SetNextWindowSize() use.
    ImGuiCond                SetWindowCollapsedAllowFlags : 8;  // store acceptable condition flags for SetNextWindowCollapsed() use.
    ImVec2                   SetWindowPosVal;                   // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
    ImVec2                   SetWindowPosPivot;                 // store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.

    ImVector_ImGuiID         IDStack;                           // ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
    ImGuiWindowTempData      DC;                                // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.

    // The best way to understand what those rectangles are is to use the 'Metrics->Tools->Show Windows Rectangles' viewer.
    // The main 'OuterRect', omitted as a field, is window->Rect().
    ImRect                   OuterRectClipped;                  // == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
    ImRect                   InnerRect;                         // Inner rectangle (omit title bar, menu bar, scroll bar)
    ImRect                   InnerClipRect;                     // == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
    ImRect                   WorkRect;                          // Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
    ImRect                   ParentWorkRect;                    // Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?
    ImRect                   ClipRect;                          // Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
    ImRect                   ContentRegionRect;                 // FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.
    ImVec2ih                 HitTestHoleSize;                   // Define an optional rectangular hole where mouse will pass-through the window.
    ImVec2ih                 HitTestHoleOffset;

    int                      LastFrameActive;                   // Last frame number the window was Active.
    float                    LastTimeActive;                    // Last timestamp the window was Active (using float as we don't need high precision there)
    float                    ItemWidthDefault;
    ImGuiStorage             StateStorage;
    ImVector_ImGuiOldColumns ColumnsStorage;
    float                    FontWindowScale;                   // User scale multiplier per-window, via SetWindowFontScale()
    int                      SettingsOffset;                    // Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)

    ImDrawList*              DrawList;                          // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
    ImDrawList               DrawListInst;
    ImGuiWindow*             ParentWindow;                      // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.
    ImGuiWindow*             RootWindow;                        // Point to ourself or first ancestor that is not a child window == Top-level window.
    ImGuiWindow*             RootWindowForTitleBarHighlight;    // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
    ImGuiWindow*             RootWindowForNav;                  // Point to ourself or first ancestor which doesn't have the NavFlattened flag.

    ImGuiWindow*             NavLastChildNavWindow;             // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
    ImGuiID                  NavLastIds[ImGuiNavLayer_COUNT];   // Last known NavId for this window, per layer (0/1)
    ImRect                   NavRectRel[ImGuiNavLayer_COUNT];   // Reference rectangle, in window relative space

    int                      MemoryDrawListIdxCapacity;         // Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy
    int                      MemoryDrawListVtxCapacity;
    bool                     MemoryCompacted;                   // Set when window extraneous data have been garbage collected
};
CIMGUI_API ImGuiID ImGuiWindow_GetIDStr(ImGuiWindow* self, const char* str);                                      // Implied str_end = NULL
CIMGUI_API ImGuiID ImGuiWindow_GetIDStrEx(ImGuiWindow* self, const char* str, const char* str_end /* = NULL */);
CIMGUI_API ImGuiID ImGuiWindow_GetID(ImGuiWindow* self, const void* ptr);
CIMGUI_API ImGuiID ImGuiWindow_GetIDInt(ImGuiWindow* self, int n);
CIMGUI_API ImGuiID ImGuiWindow_GetIDNoKeepAliveStr(ImGuiWindow* self, const char* str);                           // Implied str_end = NULL
CIMGUI_API ImGuiID ImGuiWindow_GetIDNoKeepAliveStrEx(ImGuiWindow* self, const char* str, const char* str_end /* = NULL */);
CIMGUI_API ImGuiID ImGuiWindow_GetIDNoKeepAlive(ImGuiWindow* self, const void* ptr);
CIMGUI_API ImGuiID ImGuiWindow_GetIDNoKeepAliveInt(ImGuiWindow* self, int n);
CIMGUI_API ImGuiID ImGuiWindow_GetIDFromRectangle(ImGuiWindow* self, ImRect r_abs);
// We don't use g.FontSize because the window may be != g.CurrentWidow.
CIMGUI_API ImRect  ImGuiWindow_Rect(const ImGuiWindow* self);
CIMGUI_API float   ImGuiWindow_CalcFontSize(const ImGuiWindow* self);
CIMGUI_API float   ImGuiWindow_TitleBarHeight(const ImGuiWindow* self);
CIMGUI_API ImRect  ImGuiWindow_TitleBarRect(const ImGuiWindow* self);
CIMGUI_API float   ImGuiWindow_MenuBarHeight(const ImGuiWindow* self);
CIMGUI_API ImRect  ImGuiWindow_MenuBarRect(const ImGuiWindow* self);

// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.
struct ImGuiLastItemDataBackup_t
{
    ImGuiID              LastItemId;
    ImGuiItemStatusFlags LastItemStatusFlags;
    ImRect               LastItemRect;
    ImRect               LastItemDisplayRect;
};
CIMGUI_API void ImGuiLastItemDataBackup_Backup(ImGuiLastItemDataBackup* self);
CIMGUI_API void ImGuiLastItemDataBackup_Restore(const ImGuiLastItemDataBackup* self);

//-----------------------------------------------------------------------------
// [SECTION] Tab bar, Tab item support
//-----------------------------------------------------------------------------

// Extend ImGuiTabBarFlags_
typedef enum
{
    ImGuiTabBarFlags_DockNode     = 1<<20,  // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
    ImGuiTabBarFlags_IsFocused    = 1<<21,
    ImGuiTabBarFlags_SaveSettings = 1<<22,  // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
} ImGuiTabBarFlagsPrivate_;

// Extend ImGuiTabItemFlags_
typedef enum
{
    ImGuiTabItemFlags_NoCloseButton = 1<<20,  // Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)
    ImGuiTabItemFlags_Button        = 1<<21,  // Used by TabItemButton, change the tab item behavior to mimic a button
} ImGuiTabItemFlagsPrivate_;

// Storage for one active tab item (sizeof() 28~32 bytes)
struct ImGuiTabItem_t
{
    ImGuiID           ID;
    ImGuiTabItemFlags Flags;
    int               LastFrameVisible;
    int               LastFrameSelected;  // This allows us to infer an ordered list of the last activated tabs with little maintenance
    float             Offset;             // Position relative to beginning of tab
    float             Width;              // Width currently displayed
    float             ContentWidth;       // Width of label, stored during BeginTabItem() call
    ImS16             NameOffset;         // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
    ImS16             BeginOrder;         // BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable
    ImS16             IndexDuringLayout;  // Index only used during TabBarLayout()
    bool              WantClose;          // Marked as closed by SetTabItemClosed()
};

// Storage for a tab bar (sizeof() 152 bytes)
struct ImGuiTabBar_t
{
    ImVector_ImGuiTabItem Tabs;
    ImGuiTabBarFlags      Flags;
    ImGuiID               ID;                      // Zero for tab-bars used by docking
    ImGuiID               SelectedTabId;           // Selected tab/window
    ImGuiID               NextSelectedTabId;
    ImGuiID               VisibleTabId;            // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
    int                   CurrFrameVisible;
    int                   PrevFrameVisible;
    ImRect                BarRect;
    float                 CurrTabsContentsHeight;
    float                 PrevTabsContentsHeight;  // Record the height of contents submitted below the tab bar
    float                 WidthAllTabs;            // Actual width of all tabs (locked during layout)
    float                 WidthAllTabsIdeal;       // Ideal width if all tabs were visible and not clipped
    float                 ScrollingAnim;
    float                 ScrollingTarget;
    float                 ScrollingTargetDistToVisibility;
    float                 ScrollingSpeed;
    float                 ScrollingRectMinX;
    float                 ScrollingRectMaxX;
    ImGuiID               ReorderRequestTabId;
    ImS8                  ReorderRequestDir;
    ImS8                  BeginCount;
    bool                  WantLayout;
    bool                  VisibleTabWasSubmitted;
    bool                  TabsAddedNew;            // Set to true when a new tab item or button has been added to the tab bar during last frame
    ImS16                 TabsActiveCount;         // Number of tabs submitted this frame.
    ImS16                 LastTabItemIdx;          // Index of last BeginTabItem() tab for use by EndTabItem()
    float                 ItemSpacingY;
    ImVec2                FramePadding;            // style.FramePadding locked at the time of BeginTabBar()
    ImVec2                BackupCursorPos;
    ImGuiTextBuffer       TabsNames;               // For non-docking tab bar we re-append names in a contiguous buffer.
};
CIMGUI_API int         ImGuiTabBar_GetTabOrder(const ImGuiTabBar* self, const ImGuiTabItem* tab);
CIMGUI_API const char* ImGuiTabBar_GetTabName(const ImGuiTabBar* self, const ImGuiTabItem* tab);

//-----------------------------------------------------------------------------
// [SECTION] Table support
//-----------------------------------------------------------------------------

#ifdef IMGUI_HAS_TABLE
#define IM_COL32_DISABLE                IM_COL32(0,0,0,1)    // Special sentinel code which cannot be used as a regular color.
#define IMGUI_TABLE_MAX_COLUMNS         64                   // sizeof(ImU64) * 8. This is solely because we frequently encode columns set in a ImU64.
#define IMGUI_TABLE_MAX_DRAW_CHANNELS   (4 + 64 * 2)         // See TableSetupDrawChannels()

typedef ImU8 ImGuiTableDrawChannelIdx;

// [Internal] sizeof() ~ 104
// We use the terminology "Enabled" to refer to a column that is not Hidden by user/api.
// We use the terminology "Clipped" to refer to a column that is out of sight because of scrolling/clipping.
// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible" to mean "not clipped".
struct ImGuiTableColumn_t
{
    ImGuiTableColumnFlags    Flags;                         // Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_
    float                    WidthGiven;                    // Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.
    float                    MinX;                          // Absolute positions
    float                    MaxX;
    float                    WidthRequest;                  // Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()
    float                    WidthAuto;                     // Automatic width
    float                    StretchWeight;                 // Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.
    float                    InitStretchWeightOrWidth;      // Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).
    ImRect                   ClipRect;                      // Clipping rectangle for the column
    ImGuiID                  UserID;                        // Optional, value passed to TableSetupColumn()
    float                    WorkMinX;                      // Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column
    float                    WorkMaxX;                      // Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)
    float                    ItemWidth;                     // Current item width for the column, preserved across rows
    float                    ContentMaxXFrozen;             // Contents maximum position for frozen rows (apart from headers), from which we can infer content width.
    float                    ContentMaxXUnfrozen;
    float                    ContentMaxXHeadersUsed;        // Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls
    float                    ContentMaxXHeadersIdeal;
    ImS16                    NameOffset;                    // Offset into parent ColumnsNames[]
    ImGuiTableColumnIdx      DisplayOrder;                  // Index within Table's IndexToDisplayOrder[] (column may be reordered by users)
    ImGuiTableColumnIdx      IndexWithinEnabledSet;         // Index within enabled/visible set (<= IndexToDisplayOrder)
    ImGuiTableColumnIdx      PrevEnabledColumn;             // Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column
    ImGuiTableColumnIdx      NextEnabledColumn;             // Index of next enabled/visible column within Columns[], -1 if last enabled/visible column
    ImGuiTableColumnIdx      SortOrder;                     // Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort
    ImGuiTableDrawChannelIdx DrawChannelCurrent;            // Index within DrawSplitter.Channels[]
    ImGuiTableDrawChannelIdx DrawChannelFrozen;
    ImGuiTableDrawChannelIdx DrawChannelUnfrozen;
    bool                     IsEnabled;                     // Is the column not marked Hidden by the user? (even if off view, e.g. clipped by scrolling).
    bool                     IsEnabledNextFrame;
    bool                     IsVisibleX;                    // Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).
    bool                     IsVisibleY;
    bool                     IsRequestOutput;               // Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.
    bool                     IsSkipItems;                   // Do we want item submissions to this column to be completely ignored (no layout will happen).
    bool                     IsPreserveWidthAuto;
    ImS8                     NavLayerCurrent;               // ImGuiNavLayer in 1 byte
    ImU8                     AutoFitQueue;                  // Queue of 8 values for the next 8 frames to request auto-fit
    ImU8                     CannotSkipItemsQueue;          // Queue of 8 values for the next 8 frames to disable Clipped/SkipItem
    ImU8                     SortDirection : 2;             // ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
    ImU8                     SortDirectionsAvailCount : 2;  // Number of available sort directions (0 to 3)
    ImU8                     SortDirectionsAvailMask : 4;   // Mask of available sort directions (1-bit each)
    ImU8                     SortDirectionsAvailList;       // Ordered of available sort directions (2-bits each)
};

// Transient cell data stored per row.
// sizeof() ~ 6
struct ImGuiTableCellData_t
{
    ImU32               BgColor;  // Actual color
    ImGuiTableColumnIdx Column;   // Column number
};

// FIXME-TABLE: transient data could be stored in a per-stacked table structure: DrawSplitter, SortSpecs, incoming RowData
struct ImGuiTable_t
{
    ImGuiID                    ID;
    ImGuiTableFlags            Flags;
    void*                      RawData;                       // Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]
    ImSpan_ImGuiTableColumn    Columns;                       // Point within RawData[]
    ImSpan_ImGuiTableColumnIdx DisplayOrderToIndex;           // Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)
    ImSpan_ImGuiTableCellData  RowCellData;                   // Point within RawData[]. Store cells background requests for current row.
    ImU64                      EnabledMaskByDisplayOrder;     // Column DisplayOrder -> IsEnabled map
    ImU64                      EnabledMaskByIndex;            // Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data
    ImU64                      VisibleMaskByIndex;            // Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)
    ImU64                      RequestOutputMaskByIndex;      // Column Index -> IsVisible || AutoFit (== expect user to submit items)
    ImGuiTableFlags            SettingsLoadedFlags;           // Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)
    int                        SettingsOffset;                // Offset in g.SettingsTables
    int                        LastFrameActive;
    int                        ColumnsCount;                  // Number of columns declared in BeginTable()
    int                        CurrentRow;
    int                        CurrentColumn;
    ImS16                      InstanceCurrent;               // Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.
    ImS16                      InstanceInteracted;            // Mark which instance (generally 0) of the same ID is being interacted with
    float                      RowPosY1;
    float                      RowPosY2;
    float                      RowMinHeight;                  // Height submitted to TableNextRow()
    float                      RowTextBaseline;
    float                      RowIndentOffsetX;
    ImGuiTableRowFlags         RowFlags : 16;                 // Current row flags, see ImGuiTableRowFlags_
    ImGuiTableRowFlags         LastRowFlags : 16;
    int                        RowBgColorCounter;             // Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.
    ImU32                      RowBgColor[2];                 // Background color override for current row.
    ImU32                      BorderColorStrong;
    ImU32                      BorderColorLight;
    float                      BorderX1;
    float                      BorderX2;
    float                      HostIndentX;
    float                      MinColumnWidth;
    float                      OuterPaddingX;
    float                      CellPaddingX;                  // Padding from each borders
    float                      CellPaddingY;
    float                      CellSpacingX1;                 // Spacing between non-bordered cells
    float                      CellSpacingX2;
    float                      LastOuterHeight;               // Outer height from last frame
    float                      LastFirstRowHeight;            // Height of first row from last frame
    float                      InnerWidth;                    // User value passed to BeginTable(), see comments at the top of BeginTable() for details.
    float                      ColumnsGivenWidth;             // Sum of current column width
    float                      ColumnsAutoFitWidth;           // Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window
    float                      ResizedColumnNextWidth;
    float                      ResizeLockMinContentsX2;       // Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.
    float                      RefScale;                      // Reference scale to be able to rescale columns on font/dpi changes.
    ImRect                     OuterRect;                     // Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().
    ImRect                     InnerRect;                     // InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is
    ImRect                     WorkRect;
    ImRect                     InnerClipRect;
    ImRect                     BgClipRect;                    // We use this to cpu-clip cell background color fill
    ImRect                     Bg0ClipRectForDrawCmd;         // Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped
    ImRect                     Bg2ClipRectForDrawCmd;         // Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.
    ImRect                     HostClipRect;                  // This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.
    ImRect                     HostBackupWorkRect;            // Backup of InnerWindow->WorkRect at the end of BeginTable()
    ImRect                     HostBackupParentWorkRect;      // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
    ImRect                     HostBackupInnerClipRect;       // Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()
    ImVec2                     HostBackupPrevLineSize;        // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
    ImVec2                     HostBackupCurrLineSize;        // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
    ImVec2                     HostBackupCursorMaxPos;        // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
    ImVec2                     UserOuterSize;                 // outer_size.x passed to BeginTable()
    ImVec1                     HostBackupColumnsOffset;       // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
    float                      HostBackupItemWidth;           // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
    int                        HostBackupItemWidthStackSize;  // Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()
    ImGuiWindow*               OuterWindow;                   // Parent window for the table
    ImGuiWindow*               InnerWindow;                   // Window holding the table data (== OuterWindow or a child window)
    ImGuiTextBuffer            ColumnsNames;                  // Contiguous buffer holding columns names
    ImDrawListSplitter         DrawSplitter;                  // We carry our own ImDrawList splitter to allow recursion (FIXME: could be stored outside, worst case we need 1 splitter per recursing table)
    ImGuiTableColumnSortSpecs  SortSpecsSingle;
    ImVector_ImGuiTableColumnSortSpecs SortSpecsMulti;        // FIXME-OPT: Using a small-vector pattern would work be good.
    ImGuiTableSortSpecs        SortSpecs;                     // Public facing sorts specs, this is what we return in TableGetSortSpecs()
    ImGuiTableColumnIdx        SortSpecsCount;
    ImGuiTableColumnIdx        ColumnsEnabledCount;           // Number of enabled columns (<= ColumnsCount)
    ImGuiTableColumnIdx        ColumnsEnabledFixedCount;      // Number of enabled columns (<= ColumnsCount)
    ImGuiTableColumnIdx        DeclColumnsCount;              // Count calls to TableSetupColumn()
    ImGuiTableColumnIdx        HoveredColumnBody;             // Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!
    ImGuiTableColumnIdx        HoveredColumnBorder;           // Index of column whose right-border is being hovered (for resizing).
    ImGuiTableColumnIdx        AutoFitSingleColumn;           // Index of single column requesting auto-fit.
    ImGuiTableColumnIdx        ResizedColumn;                 // Index of column being resized. Reset when InstanceCurrent==0.
    ImGuiTableColumnIdx        LastResizedColumn;             // Index of column being resized from previous frame.
    ImGuiTableColumnIdx        HeldHeaderColumn;              // Index of column header being held.
    ImGuiTableColumnIdx        ReorderColumn;                 // Index of column being reordered. (not cleared)
    ImGuiTableColumnIdx        ReorderColumnDir;              // -1 or +1
    ImGuiTableColumnIdx        LeftMostStretchedColumn;       // Index of left-most stretched column.
    ImGuiTableColumnIdx        RightMostStretchedColumn;      // Index of right-most stretched column.
    ImGuiTableColumnIdx        RightMostEnabledColumn;        // Index of right-most non-hidden column.
    ImGuiTableColumnIdx        ContextPopupColumn;            // Column right-clicked on, of -1 if opening context menu from a neutral/empty spot
    ImGuiTableColumnIdx        FreezeRowsRequest;             // Requested frozen rows count
    ImGuiTableColumnIdx        FreezeRowsCount;               // Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)
    ImGuiTableColumnIdx        FreezeColumnsRequest;          // Requested frozen columns count
    ImGuiTableColumnIdx        FreezeColumnsCount;            // Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)
    ImGuiTableColumnIdx        RowCellDataCurrent;            // Index of current RowCellData[] entry in current row
    ImGuiTableDrawChannelIdx   DummyDrawChannel;              // Redirect non-visible columns here.
    ImGuiTableDrawChannelIdx   Bg2DrawChannelCurrent;         // For Selectable() and other widgets drawing accross columns after the freezing line. Index within DrawSplitter.Channels[]
    ImGuiTableDrawChannelIdx   Bg2DrawChannelUnfrozen;
    bool                       IsLayoutLocked;                // Set by TableUpdateLayout() which is called when beginning the first row.
    bool                       IsInsideRow;                   // Set when inside TableBeginRow()/TableEndRow().
    bool                       IsInitializing;
    bool                       IsSortSpecsDirty;
    bool                       IsUsingHeaders;                // Set when the first row had the ImGuiTableRowFlags_Headers flag.
    bool                       IsContextPopupOpen;            // Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).
    bool                       IsSettingsRequestLoad;
    bool                       IsSettingsDirty;               // Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.
    bool                       IsDefaultDisplayOrder;         // Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)
    bool                       IsResetAllRequest;
    bool                       IsResetDisplayOrderRequest;
    bool                       IsUnfrozenRows;                // Set when we got past the frozen row.
    bool                       IsDefaultSizingPolicy;         // Set if user didn't explicitely set a sizing policy in BeginTable()
    bool                       MemoryCompacted;
    bool                       HostSkipItems;                 // Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis
};

// sizeof() ~ 12
struct ImGuiTableColumnSettings_t
{
    float               WidthOrWeight;
    ImGuiID             UserID;
    ImGuiTableColumnIdx Index;
    ImGuiTableColumnIdx DisplayOrder;
    ImGuiTableColumnIdx SortOrder;
    ImU8                SortDirection : 2;
    ImU8                IsEnabled : 1;  // "Visible" in ini file
    ImU8                IsStretch : 1;
};

// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)
struct ImGuiTableSettings_t
{
    ImGuiID             ID;               // Set to 0 to invalidate/delete the setting
    ImGuiTableFlags     SaveFlags;        // Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)
    float               RefScale;         // Reference scale to be able to rescale columns on font/dpi changes.
    ImGuiTableColumnIdx ColumnsCount;
    ImGuiTableColumnIdx ColumnsCountMax;  // Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher
    bool                WantApply;        // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
};
CIMGUI_API ImGuiTableColumnSettings* ImGuiTableSettings_GetColumnSettings(ImGuiTableSettings* self);
#endif// #ifdef IMGUI_HAS_TABLE
//-----------------------------------------------------------------------------
// [SECTION] Internal API
// No guarantee of forward compatibility here!
//-----------------------------------------------------------------------------

// Windows
// We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
// If this ever crash because g.CurrentWindow is NULL it means that either
// - ImGui::NewFrame() has never been called, which is illegal.
// - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
CIMGUI_API ImGuiWindow* ImGui_GetCurrentWindowRead(void);
CIMGUI_API ImGuiWindow* ImGui_GetCurrentWindow(void);
CIMGUI_API ImGuiWindow* ImGui_FindWindowByID(ImGuiID id);
CIMGUI_API ImGuiWindow* ImGui_FindWindowByName(const char* name);
CIMGUI_API void         ImGui_UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window);
CIMGUI_API ImVec2       ImGui_CalcWindowNextAutoFitSize(ImGuiWindow* window);
CIMGUI_API bool         ImGui_IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);
CIMGUI_API bool         ImGui_IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below);
CIMGUI_API bool         ImGui_IsWindowNavFocusable(ImGuiWindow* window);
CIMGUI_API ImRect       ImGui_GetWindowAllowedExtentRect(ImGuiWindow* window);
CIMGUI_API void         ImGui_SetWindowPosImGuiWindowPtr(ImGuiWindow* window, ImVec2 pos, ImGuiCond cond /* = 0 */);
CIMGUI_API void         ImGui_SetWindowSizeImGuiWindowPtr(ImGuiWindow* window, ImVec2 size, ImGuiCond cond /* = 0 */);
CIMGUI_API void         ImGui_SetWindowCollapsedImGuiWindowPtr(ImGuiWindow* window, bool collapsed, ImGuiCond cond /* = 0 */);
CIMGUI_API void         ImGui_SetWindowHitTestHole(ImGuiWindow* window, ImVec2 pos, ImVec2 size);

// Windows: Display Order and Focus Order
CIMGUI_API void ImGui_FocusWindow(ImGuiWindow* window);
CIMGUI_API void ImGui_FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window);
CIMGUI_API void ImGui_BringWindowToFocusFront(ImGuiWindow* window);
CIMGUI_API void ImGui_BringWindowToDisplayFront(ImGuiWindow* window);
CIMGUI_API void ImGui_BringWindowToDisplayBack(ImGuiWindow* window);

// Fonts, drawing
CIMGUI_API void        ImGui_SetCurrentFont(ImFont* font);
CIMGUI_API ImFont*     ImGui_GetDefaultFont(void);
CIMGUI_API ImDrawList* ImGui_GetForegroundDrawListImGuiWindowPtr(ImGuiWindow* window);  // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.

// Init
CIMGUI_API void ImGui_Initialize(ImGuiContext* context);
CIMGUI_API void ImGui_Shutdown(ImGuiContext* context);  // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

// NewFrame
CIMGUI_API void ImGui_UpdateHoveredWindowAndCaptureFlags(void);
CIMGUI_API void ImGui_StartMouseMovingWindow(ImGuiWindow* window);
CIMGUI_API void ImGui_UpdateMouseMovingWindowNewFrame(void);
CIMGUI_API void ImGui_UpdateMouseMovingWindowEndFrame(void);

// Generic context hooks
CIMGUI_API void ImGui_AddContextHook(ImGuiContext* context, const ImGuiContextHook* hook);
CIMGUI_API void ImGui_CallContextHooks(ImGuiContext* context, ImGuiContextHookType type);

// Settings
CIMGUI_API void                  ImGui_MarkIniSettingsDirty(void);
CIMGUI_API void                  ImGui_MarkIniSettingsDirtyImGuiWindowPtr(ImGuiWindow* window);
CIMGUI_API void                  ImGui_ClearIniSettings(void);
CIMGUI_API ImGuiWindowSettings*  ImGui_CreateNewWindowSettings(const char* name);
CIMGUI_API ImGuiWindowSettings*  ImGui_FindWindowSettings(ImGuiID id);
CIMGUI_API ImGuiWindowSettings*  ImGui_FindOrCreateWindowSettings(const char* name);
CIMGUI_API ImGuiSettingsHandler* ImGui_FindSettingsHandler(const char* type_name);

// Scrolling
CIMGUI_API void   ImGui_SetNextWindowScroll(ImVec2 scroll);                                                         // Use -1.0f on one axis to leave as-is
CIMGUI_API void   ImGui_SetScrollXImGuiWindowPtr(ImGuiWindow* window, float scroll_x);
CIMGUI_API void   ImGui_SetScrollYImGuiWindowPtr(ImGuiWindow* window, float scroll_y);
CIMGUI_API void   ImGui_SetScrollFromPosXImGuiWindowPtr(ImGuiWindow* window, float local_x, float center_x_ratio);
CIMGUI_API void   ImGui_SetScrollFromPosYImGuiWindowPtr(ImGuiWindow* window, float local_y, float center_y_ratio);
CIMGUI_API ImVec2 ImGui_ScrollToBringRectIntoView(ImGuiWindow* window, ImRect item_rect);

// Basic Accessors
CIMGUI_API ImGuiID              ImGui_GetItemID(void);                               // Get ID of last item (~~ often same ImGui::GetID(label) beforehand)
CIMGUI_API ImGuiItemStatusFlags ImGui_GetItemStatusFlags(void);
CIMGUI_API ImGuiID              ImGui_GetActiveID(void);
CIMGUI_API ImGuiID              ImGui_GetFocusID(void);
CIMGUI_API ImGuiItemFlags       ImGui_GetItemsFlags(void);
CIMGUI_API void                 ImGui_SetActiveID(ImGuiID id, ImGuiWindow* window);
CIMGUI_API void                 ImGui_SetFocusID(ImGuiID id, ImGuiWindow* window);
CIMGUI_API void                 ImGui_ClearActiveID(void);
CIMGUI_API ImGuiID              ImGui_GetHoveredID(void);
CIMGUI_API void                 ImGui_SetHoveredID(ImGuiID id);
CIMGUI_API void                 ImGui_KeepAliveID(ImGuiID id);
CIMGUI_API void                 ImGui_MarkItemEdited(ImGuiID id);                    // Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
CIMGUI_API void                 ImGui_PushOverrideID(ImGuiID id);                    // Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)
CIMGUI_API ImGuiID              ImGui_GetIDWithSeed(const char* str_id_begin, const char* str_id_end, ImGuiID seed);

// Basic Helpers for widget code
CIMGUI_API void   ImGui_ItemSize(ImVec2 size);                                                     // Implied text_baseline_y = -1.0f
CIMGUI_API void   ImGui_ItemSizeEx(ImVec2 size, float text_baseline_y /* = -1.0f */);
CIMGUI_API void   ImGui_ItemSizeImRect(ImRect bb);                                                 // Implied text_baseline_y = -1.0f
CIMGUI_API void   ImGui_ItemSizeImRectEx(ImRect bb, float text_baseline_y /* = -1.0f */);
CIMGUI_API bool   ImGui_ItemAdd(ImRect bb, ImGuiID id);                                            // Implied nav_bb = NULL
CIMGUI_API bool   ImGui_ItemAddEx(ImRect bb, ImGuiID id, const ImRect* nav_bb /* = NULL */);
CIMGUI_API bool   ImGui_ItemHoverable(ImRect bb, ImGuiID id);
CIMGUI_API bool   ImGui_IsClippedEx(ImRect bb, ImGuiID id, bool clip_even_when_logged);
CIMGUI_API void   ImGui_SetLastItemData(ImGuiWindow* window, ImGuiID item_id, ImGuiItemStatusFlags status_flags, ImRect item_rect);
CIMGUI_API bool   ImGui_FocusableItemRegister(ImGuiWindow* window, ImGuiID id);                    // Return true if focus is requested
CIMGUI_API void   ImGui_FocusableItemUnregister(ImGuiWindow* window);
CIMGUI_API ImVec2 ImGui_CalcItemSize(ImVec2 size, float default_w, float default_h);
CIMGUI_API float  ImGui_CalcWrapWidthForPos(ImVec2 pos, float wrap_pos_x);
CIMGUI_API void   ImGui_PushMultiItemsWidths(int components, float width_full);
CIMGUI_API void   ImGui_PushItemFlag(ImGuiItemFlags option, bool enabled);
CIMGUI_API void   ImGui_PopItemFlag(void);
CIMGUI_API bool   ImGui_IsItemToggledSelection(void);                                              // Was the last item selection toggled? (after Selectable(), TreeNode() etc. We only returns toggle _event_ in order to handle clipping correctly)
CIMGUI_API ImVec2 ImGui_GetContentRegionMaxAbs(void);
CIMGUI_API void   ImGui_ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess);

// Logging/Capture
CIMGUI_API void ImGui_LogBegin(ImGuiLogType type, int auto_open_depth);  // -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
CIMGUI_API void ImGui_LogToBuffer(void);                                 // Implied auto_open_depth = -1
CIMGUI_API void ImGui_LogToBufferEx(int auto_open_depth /* = -1 */);     // Start logging/capturing to internal buffer

// Popups, Modals, Tooltips
CIMGUI_API bool         ImGui_BeginChildEx(const char* name, ImGuiID id, ImVec2 size_arg, bool border, ImGuiWindowFlags flags);
CIMGUI_API void         ImGui_OpenPopupEx(ImGuiID id);                                                                   // Implied popup_flags = ImGuiPopupFlags_None
CIMGUI_API void         ImGui_OpenPopupExEx(ImGuiID id, ImGuiPopupFlags popup_flags /* = ImGuiPopupFlags_None */);
CIMGUI_API void         ImGui_ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);
CIMGUI_API void         ImGui_ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup);
CIMGUI_API bool         ImGui_IsPopupOpenID(ImGuiID id, ImGuiPopupFlags popup_flags);
CIMGUI_API bool         ImGui_BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);
CIMGUI_API void         ImGui_BeginTooltipEx(ImGuiWindowFlags extra_flags, ImGuiTooltipFlags tooltip_flags);
CIMGUI_API ImGuiWindow* ImGui_GetTopMostPopupModal(void);
CIMGUI_API ImVec2       ImGui_FindBestWindowPosForPopup(ImGuiWindow* window);
CIMGUI_API ImVec2       ImGui_FindBestWindowPosForPopupEx(ImVec2 ref_pos, ImVec2 size, ImGuiDir* last_dir, ImRect r_outer, ImRect r_avoid, ImGuiPopupPositionPolicy policy);

// Gamepad/Keyboard Navigation
CIMGUI_API void   ImGui_NavInitWindow(ImGuiWindow* window, bool force_reinit);
CIMGUI_API bool   ImGui_NavMoveRequestButNoResultYet(void);
CIMGUI_API void   ImGui_NavMoveRequestCancel(void);
CIMGUI_API void   ImGui_NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, ImRect bb_rel, ImGuiNavMoveFlags move_flags);
CIMGUI_API void   ImGui_NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags);
CIMGUI_API float  ImGui_GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);
CIMGUI_API ImVec2 ImGui_GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode);         // Implied slow_factor = 0.0f, fast_factor = 0.0f
CIMGUI_API ImVec2 ImGui_GetNavInputAmount2dEx(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor /* = 0.0f */, float fast_factor /* = 0.0f */);
CIMGUI_API int    ImGui_CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);
CIMGUI_API void   ImGui_ActivateItem(ImGuiID id);                                                                 // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.
CIMGUI_API void   ImGui_SetNavID(ImGuiID id, int nav_layer, ImGuiID focus_scope_id);
CIMGUI_API void   ImGui_SetNavIDWithRectRel(ImGuiID id, int nav_layer, ImGuiID focus_scope_id, ImRect rect_rel);

// Focus Scope (WIP)
// This is generally used to identify a selection set (multiple of which may be in the same window), as selection
// patterns generally need to react (e.g. clear selection) when landing on an item of the set.
CIMGUI_API void    ImGui_PushFocusScope(ImGuiID id);
CIMGUI_API void    ImGui_PopFocusScope(void);
CIMGUI_API ImGuiID ImGui_GetFocusedFocusScope(void);  // Focus scope which is actually active
CIMGUI_API ImGuiID ImGui_GetFocusScope(void);         // Focus scope we are outputting into, set by PushFocusScope()

// Inputs
// FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into IsKeyXXX functions.
CIMGUI_API void             ImGui_SetItemUsingMouseWheel(void);
CIMGUI_API bool             ImGui_IsActiveIdUsingNavDir(ImGuiDir dir);
CIMGUI_API bool             ImGui_IsActiveIdUsingNavInput(ImGuiNavInput input);
CIMGUI_API bool             ImGui_IsActiveIdUsingKey(ImGuiKey key);
CIMGUI_API bool             ImGui_IsMouseDragPastThreshold(ImGuiMouseButton button);                                        // Implied lock_threshold = -1.0f
CIMGUI_API bool             ImGui_IsMouseDragPastThresholdEx(ImGuiMouseButton button, float lock_threshold /* = -1.0f */);
CIMGUI_API bool             ImGui_IsKeyPressedMap(ImGuiKey key);                                                            // Implied repeat = true
CIMGUI_API bool             ImGui_IsKeyPressedMapEx(ImGuiKey key, bool repeat /* = true */);
CIMGUI_API bool             ImGui_IsNavInputDown(ImGuiNavInput n);
CIMGUI_API bool             ImGui_IsNavInputTest(ImGuiNavInput n, ImGuiInputReadMode rm);
CIMGUI_API ImGuiKeyModFlags ImGui_GetMergedKeyModFlags(void);

// Drag and Drop
CIMGUI_API bool ImGui_BeginDragDropTargetCustom(ImRect bb, ImGuiID id);
CIMGUI_API void ImGui_ClearDragDrop(void);
CIMGUI_API bool ImGui_IsDragDropPayloadBeingAccepted(void);

// Internal Columns API (this is not exposed because we will encourage transitioning to the Tables API)
CIMGUI_API void             ImGui_SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, ImRect clip_rect);
CIMGUI_API void             ImGui_BeginColumns(const char* str_id, int count, ImGuiOldColumnFlags flags /* = 0 */);  // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
CIMGUI_API void             ImGui_EndColumns(void);                                                                  // close columns
CIMGUI_API void             ImGui_PushColumnClipRect(int column_index);
CIMGUI_API void             ImGui_PushColumnsBackground(void);
CIMGUI_API void             ImGui_PopColumnsBackground(void);
CIMGUI_API ImGuiID          ImGui_GetColumnsID(const char* str_id, int count);
CIMGUI_API ImGuiOldColumns* ImGui_FindOrCreateColumns(ImGuiWindow* window, ImGuiID id);
CIMGUI_API float            ImGui_GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm);
CIMGUI_API float            ImGui_GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset);

// Tables: Candidates for public API
CIMGUI_API void  ImGui_TableOpenContextMenu(void);                       // Implied column_n = -1
CIMGUI_API void  ImGui_TableOpenContextMenuEx(int column_n /* = -1 */);
CIMGUI_API void  ImGui_TableSetColumnWidth(int column_n, float width);
CIMGUI_API void  ImGui_TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs);
CIMGUI_API int   ImGui_TableGetHoveredColumn(void);                      // May use (TableGetColumnFlags() & ImGuiTableColumnFlags_IsHovered) instead. Return hovered column. return -1 when table is not hovered. return columns_count if the unused space at the right of visible columns is hovered.
CIMGUI_API float ImGui_TableGetHeaderRowHeight(void);
CIMGUI_API void  ImGui_TablePushBackgroundChannel(void);
CIMGUI_API void  ImGui_TablePopBackgroundChannel(void);

// Tables: Internals
CIMGUI_API ImGuiTable*        ImGui_TableFindByID(ImGuiID id);
CIMGUI_API bool               ImGui_BeginTableWithID(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags /* = 0 */); // Implied outer_size = ImVec2(0, 0), inner_width = 0.0f
CIMGUI_API bool               ImGui_BeginTableWithIDEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags /* = 0 */, ImVec2 outer_size /* = ImVec2(0, 0) */, float inner_width /* = 0.0f */);
CIMGUI_API void               ImGui_TableBeginInitMemory(ImGuiTable* table, int columns_count);
CIMGUI_API void               ImGui_TableBeginApplyRequests(ImGuiTable* table);
CIMGUI_API void               ImGui_TableSetupDrawChannels(ImGuiTable* table);
CIMGUI_API void               ImGui_TableUpdateLayout(ImGuiTable* table);
CIMGUI_API void               ImGui_TableUpdateBorders(ImGuiTable* table);
CIMGUI_API void               ImGui_TableUpdateColumnsWeightFromWidth(ImGuiTable* table);
CIMGUI_API void               ImGui_TableDrawBorders(ImGuiTable* table);
CIMGUI_API void               ImGui_TableDrawContextMenu(ImGuiTable* table);
CIMGUI_API void               ImGui_TableMergeDrawChannels(ImGuiTable* table);
CIMGUI_API void               ImGui_TableSortSpecsSanitize(ImGuiTable* table);
CIMGUI_API void               ImGui_TableSortSpecsBuild(ImGuiTable* table);
CIMGUI_API ImGuiSortDirection ImGui_TableGetColumnNextSortDirection(ImGuiTableColumn* column);
CIMGUI_API void               ImGui_TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column);
CIMGUI_API float              ImGui_TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column);
CIMGUI_API void               ImGui_TableBeginRow(ImGuiTable* table);
CIMGUI_API void               ImGui_TableEndRow(ImGuiTable* table);
CIMGUI_API void               ImGui_TableBeginCell(ImGuiTable* table, int column_n);
CIMGUI_API void               ImGui_TableEndCell(ImGuiTable* table);
CIMGUI_API ImRect             ImGui_TableGetCellBgRect(const ImGuiTable* table, int column_n);
CIMGUI_API const char*        ImGui_TableGetColumnNameImGuiTablePtr(const ImGuiTable* table, int column_n);
CIMGUI_API ImGuiID            ImGui_TableGetColumnResizeID(const ImGuiTable* table, int column_n);                               // Implied instance_no = 0
CIMGUI_API ImGuiID            ImGui_TableGetColumnResizeIDEx(const ImGuiTable* table, int column_n, int instance_no /* = 0 */);
CIMGUI_API float              ImGui_TableGetMaxColumnWidth(const ImGuiTable* table, int column_n);
CIMGUI_API void               ImGui_TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n);
CIMGUI_API void               ImGui_TableSetColumnWidthAutoAll(ImGuiTable* table);
CIMGUI_API void               ImGui_TableRemove(ImGuiTable* table);
CIMGUI_API void               ImGui_TableGcCompactTransientBuffers(ImGuiTable* table);
CIMGUI_API void               ImGui_TableGcCompactSettings(void);

// Tables: Settings
CIMGUI_API void                ImGui_TableLoadSettings(ImGuiTable* table);
CIMGUI_API void                ImGui_TableSaveSettings(ImGuiTable* table);
CIMGUI_API void                ImGui_TableResetSettings(ImGuiTable* table);
CIMGUI_API ImGuiTableSettings* ImGui_TableGetBoundSettings(ImGuiTable* table);
CIMGUI_API void                ImGui_TableSettingsInstallHandler(ImGuiContext* context);
CIMGUI_API ImGuiTableSettings* ImGui_TableSettingsCreate(ImGuiID id, int columns_count);
CIMGUI_API ImGuiTableSettings* ImGui_TableSettingsFindByID(ImGuiID id);

// Tab Bars
CIMGUI_API bool          ImGui_BeginTabBarEx(ImGuiTabBar* tab_bar, ImRect bb, ImGuiTabBarFlags flags);
CIMGUI_API ImGuiTabItem* ImGui_TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id);
CIMGUI_API void          ImGui_TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id);
CIMGUI_API void          ImGui_TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab);
CIMGUI_API void          ImGui_TabBarQueueReorder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir);
CIMGUI_API bool          ImGui_TabBarProcessReorder(ImGuiTabBar* tab_bar);
CIMGUI_API bool          ImGui_TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags);
CIMGUI_API ImVec2        ImGui_TabItemCalcSize(const char* label, bool has_close_button);
CIMGUI_API void          ImGui_TabItemBackground(ImDrawList* draw_list, ImRect bb, ImGuiTabItemFlags flags, ImU32 col);
CIMGUI_API void          ImGui_TabItemLabelAndCloseButton(ImDrawList* draw_list, ImRect bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped);

// Render helpers
// AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
// NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
CIMGUI_API void        ImGui_RenderText(ImVec2 pos, const char* text);                                                                                                   // Implied text_end = NULL, hide_text_after_hash = true
CIMGUI_API void        ImGui_RenderTextEx(ImVec2 pos, const char* text, const char* text_end /* = NULL */, bool hide_text_after_hash /* = true */);
CIMGUI_API void        ImGui_RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);
CIMGUI_API void        ImGui_RenderTextClipped(ImVec2 pos_min, ImVec2 pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known);                // Implied align = ImVec2(0, 0), clip_rect = NULL
CIMGUI_API void        ImGui_RenderTextClippedEx(ImVec2 pos_min, ImVec2 pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, ImVec2 align /* = ImVec2(0, 0) */, const ImRect* clip_rect /* = NULL */);
CIMGUI_API void        ImGui_RenderTextClippedWithDrawList(ImDrawList* draw_list, ImVec2 pos_min, ImVec2 pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known); // Implied align = ImVec2(0, 0), clip_rect = NULL
CIMGUI_API void        ImGui_RenderTextClippedWithDrawListEx(ImDrawList* draw_list, ImVec2 pos_min, ImVec2 pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, ImVec2 align /* = ImVec2(0, 0) */, const ImRect* clip_rect /* = NULL */);
CIMGUI_API void        ImGui_RenderTextEllipsis(ImDrawList* draw_list, ImVec2 pos_min, ImVec2 pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end, const ImVec2* text_size_if_known);
CIMGUI_API void        ImGui_RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col);                                                                                    // Implied border = true, rounding = 0.0f
CIMGUI_API void        ImGui_RenderFrameEx(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border /* = true */, float rounding /* = 0.0f */);
CIMGUI_API void        ImGui_RenderFrameBorder(ImVec2 p_min, ImVec2 p_max);                                                                                              // Implied rounding = 0.0f
CIMGUI_API void        ImGui_RenderFrameBorderEx(ImVec2 p_min, ImVec2 p_max, float rounding /* = 0.0f */);
CIMGUI_API void        ImGui_RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off);  // Implied rounding = 0.0f, rounding_corners_flags = ~0
CIMGUI_API void        ImGui_RenderColorRectWithAlphaCheckerboardEx(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding /* = 0.0f */, int rounding_corners_flags /* = ~0 */);
CIMGUI_API void        ImGui_RenderNavHighlight(ImRect bb, ImGuiID id);                                                                                                  // Implied flags = ImGuiNavHighlightFlags_TypeDefault
CIMGUI_API void        ImGui_RenderNavHighlightEx(ImRect bb, ImGuiID id, ImGuiNavHighlightFlags flags /* = ImGuiNavHighlightFlags_TypeDefault */);                       // Navigation highlight
CIMGUI_API const char* ImGui_FindRenderedTextEnd(const char* text);                                                                                                      // Implied text_end = NULL
CIMGUI_API const char* ImGui_FindRenderedTextEndEx(const char* text, const char* text_end /* = NULL */);                                                                 // Find the optional ## from which we stop displaying text.
CIMGUI_API void        ImGui_LogRenderedText(const ImVec2* ref_pos, const char* text);                                                                                   // Implied text_end = NULL
CIMGUI_API void        ImGui_LogRenderedTextEx(const ImVec2* ref_pos, const char* text, const char* text_end /* = NULL */);

// Render helpers (those functions don't access any ImGui state!)
CIMGUI_API void ImGui_RenderArrowImDrawListPtr(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir);                                         // Implied scale = 1.0f
CIMGUI_API void ImGui_RenderArrowImDrawListPtrEx(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale /* = 1.0f */);
CIMGUI_API void ImGui_RenderBulletImDrawListPtr(ImDrawList* draw_list, ImVec2 pos, ImU32 col);
CIMGUI_API void ImGui_RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz);
CIMGUI_API void ImGui_RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow);
CIMGUI_API void ImGui_RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col);
CIMGUI_API void ImGui_RenderRectFilledRangeH(ImDrawList* draw_list, ImRect rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);
CIMGUI_API void ImGui_RenderRectFilledWithHole(ImDrawList* draw_list, ImRect outer, ImRect inner, ImU32 col, float rounding);

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
// [1.71: 2019/06/07: Updating prototypes of some of the internal functions. Leaving those for reference for a short while]
CIMGUI_API void ImGui_RenderArrow(ImVec2 pos, ImGuiDir dir);                              // Implied scale = 1.0f
CIMGUI_API void ImGui_RenderArrowEx(ImVec2 pos, ImGuiDir dir, float scale /* = 1.0f */);
CIMGUI_API void ImGui_RenderBullet(ImVec2 pos);
#endif // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
// Widgets
CIMGUI_API void    ImGui_TextEx(const char* text);                                                                            // Implied text_end = NULL, flags = 0
CIMGUI_API void    ImGui_TextExEx(const char* text, const char* text_end /* = NULL */, ImGuiTextFlags flags /* = 0 */);
CIMGUI_API bool    ImGui_ButtonWithFlags(const char* label);                                                                  // Implied size_arg = ImVec2(0, 0), flags = 0
CIMGUI_API bool    ImGui_ButtonWithFlagsEx(const char* label, ImVec2 size_arg /* = ImVec2(0, 0) */, ImGuiButtonFlags flags /* = 0 */);
CIMGUI_API bool    ImGui_CloseButton(ImGuiID id, ImVec2 pos);
CIMGUI_API bool    ImGui_CollapseButton(ImGuiID id, ImVec2 pos);
CIMGUI_API bool    ImGui_ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size_arg, ImGuiButtonFlags flags /* = 0 */);
CIMGUI_API void    ImGui_Scrollbar(ImGuiAxis axis);
CIMGUI_API bool    ImGui_ScrollbarEx(ImRect bb, ImGuiID id, ImGuiAxis axis, float* p_scroll_v, float avail_v, float contents_v, ImDrawCornerFlags rounding_corners);
CIMGUI_API bool    ImGui_ImageButtonWithFlags(ImGuiID id, ImTextureID texture_id, ImVec2 size, ImVec2 uv0, ImVec2 uv1, ImVec2 padding, ImVec4 bg_col, ImVec4 tint_col);
CIMGUI_API ImRect  ImGui_GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis);
CIMGUI_API ImGuiID ImGui_GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis);
CIMGUI_API ImGuiID ImGui_GetWindowResizeID(ImGuiWindow* window, int n);                                                       // 0..3: corners, 4..7: borders
CIMGUI_API void    ImGui_SeparatorEx(ImGuiSeparatorFlags flags);
CIMGUI_API bool    ImGui_CheckboxFlagsImS64Ptr(const char* label, ImS64* flags, ImS64 flags_value);
CIMGUI_API bool    ImGui_CheckboxFlagsImU64Ptr(const char* label, ImU64* flags, ImU64 flags_value);

// Widgets low-level behaviors
CIMGUI_API bool ImGui_ButtonBehavior(ImRect bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags /* = 0 */);
CIMGUI_API bool ImGui_DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags);
CIMGUI_API bool ImGui_SliderBehavior(ImRect bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb);
CIMGUI_API bool ImGui_SplitterBehavior(ImRect bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2);  // Implied hover_extend = 0.0f, hover_visibility_delay = 0.0f
CIMGUI_API bool ImGui_SplitterBehaviorEx(ImRect bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend /* = 0.0f */, float hover_visibility_delay /* = 0.0f */);
CIMGUI_API bool ImGui_TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label);                                              // Implied label_end = NULL
CIMGUI_API bool ImGui_TreeNodeBehaviorEx(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end /* = NULL */);
CIMGUI_API bool ImGui_TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags /* = 0 */);                                                 // Consume previous SetNextItemOpen() data, if any. May return true when logging
CIMGUI_API void ImGui_TreePushOverrideID(ImGuiID id);

// Data type helpers
CIMGUI_API const ImGuiDataTypeInfo* ImGui_DataTypeGetInfo(ImGuiDataType data_type);
CIMGUI_API int                      ImGui_DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format);
CIMGUI_API void                     ImGui_DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, const void* arg_1, const void* arg_2);
CIMGUI_API bool                     ImGui_DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* p_data, const char* format);
CIMGUI_API int                      ImGui_DataTypeCompare(ImGuiDataType data_type, const void* arg_1, const void* arg_2);
CIMGUI_API bool                     ImGui_DataTypeClamp(ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max);

// InputText
CIMGUI_API bool ImGui_InputTextWithHintAndSize(const char* label, const char* hint, char* buf, int buf_size, ImVec2 size_arg, ImGuiInputTextFlags flags);  // Implied callback = NULL, user_data = NULL
CIMGUI_API bool ImGui_InputTextWithHintAndSizeEx(const char* label, const char* hint, char* buf, int buf_size, ImVec2 size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback /* = NULL */, void* user_data /* = NULL */);
CIMGUI_API bool ImGui_TempInputText(ImRect bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags);
CIMGUI_API bool ImGui_TempInputScalar(ImRect bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format);                // Implied p_clamp_min = NULL, p_clamp_max = NULL
CIMGUI_API bool ImGui_TempInputScalarEx(ImRect bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format, const void* p_clamp_min /* = NULL */, const void* p_clamp_max /* = NULL */);
CIMGUI_API bool ImGui_TempInputIsActive(ImGuiID id);

// Color
CIMGUI_API void ImGui_ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);
CIMGUI_API void ImGui_ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);
CIMGUI_API void ImGui_ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags);

// Plot
CIMGUI_API int ImGui_PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size);

// Shade functions (write over already created vertices)
CIMGUI_API void ImGui_ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
CIMGUI_API void ImGui_ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 a, ImVec2 b, ImVec2 uv_a, ImVec2 uv_b, bool clamp);

// Garbage collection
CIMGUI_API void ImGui_GcCompactTransientMiscBuffers(void);
CIMGUI_API void ImGui_GcCompactTransientWindowBuffers(ImGuiWindow* window);
CIMGUI_API void ImGui_GcAwakeTransientWindowBuffers(ImGuiWindow* window);

// Debug Tools
CIMGUI_API void ImGui_ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback);                                  // Implied user_data = NULL
CIMGUI_API void ImGui_ErrorCheckEndFrameRecoverEx(ImGuiErrorLogCallback log_callback, void* user_data /* = NULL */);
CIMGUI_API void ImGui_DebugDrawItemRect(void);                                                                        // Implied col = IM_COL32(255, 0, 0, 255)
CIMGUI_API void ImGui_DebugDrawItemRectEx(ImU32 col /* = IM_COL32(255, 0, 0, 255) */);
CIMGUI_API void ImGui_DebugStartItemPicker(void);

CIMGUI_API void ImGui_DebugNodeColumns(ImGuiOldColumns* columns);
CIMGUI_API void ImGui_DebugNodeDrawList(ImGuiWindow* window, const ImDrawList* draw_list, const char* label);
CIMGUI_API void ImGui_DebugNodeDrawCmdShowMeshAndBoundingBox(ImGuiWindow* window, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb);
CIMGUI_API void ImGui_DebugNodeStorage(ImGuiStorage* storage, const char* label);
CIMGUI_API void ImGui_DebugNodeTabBar(ImGuiTabBar* tab_bar, const char* label);
CIMGUI_API void ImGui_DebugNodeTable(ImGuiTable* table);
CIMGUI_API void ImGui_DebugNodeTableSettings(ImGuiTableSettings* settings);
CIMGUI_API void ImGui_DebugNodeWindow(ImGuiWindow* window, const char* label);
CIMGUI_API void ImGui_DebugNodeWindowSettings(ImGuiWindowSettings* settings);
CIMGUI_API void ImGui_DebugNodeWindowsList(ImVector_ImGuiWindowPtr* windows, const char* label);

// ImFontAtlas internals
CIMGUI_API bool cImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);
CIMGUI_API void cImFontAtlasBuildInit(ImFontAtlas* atlas);
CIMGUI_API void cImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);
CIMGUI_API void cImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque);
CIMGUI_API void cImFontAtlasBuildFinish(ImFontAtlas* atlas);
CIMGUI_API void cImFontAtlasBuildRender1bppRectFromString(ImFontAtlas* atlas, int atlas_x, int atlas_y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value);
CIMGUI_API void cImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
CIMGUI_API void cImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);

//-----------------------------------------------------------------------------
// [SECTION] Test Engine specific hooks (imgui_test_engine)
//-----------------------------------------------------------------------------

#ifdef IMGUI_ENABLE_TEST_ENGINE
extern
CIMGUI_API void cImGuiTestEngineHook_ItemAdd(ImGuiContext* ctx, ImRect bb, ImGuiID id);
extern
CIMGUI_API void cImGuiTestEngineHook_ItemInfo(ImGuiContext* ctx, ImGuiID id, const char* label, ImGuiItemStatusFlags flags);
extern
CIMGUI_API void cImGuiTestEngineHook_IdInfo(ImGuiContext* ctx, ImGuiDataType data_type, ImGuiID id, const void* data_id);
extern
CIMGUI_API void cImGuiTestEngineHook_IdInfoPtr(ImGuiContext* ctx, ImGuiDataType data_type, ImGuiID id, const void* data_id, const void* data_id_end);
extern
CIMGUI_API void cImGuiTestEngineHook_Log(ImGuiContext* ctx, const char* fmt, ...);
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB,_ID)                 if (g.TestEngineHookItems) ImGuiTestEngineHook_ItemAdd(&g, _BB, _ID)                                                        // Register item bounding box
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      if (g.TestEngineHookItems) ImGuiTestEngineHook_ItemInfo(&g, _ID, _LABEL, _FLAGS)                                            // Register item label and status flags (optional)
#define IMGUI_TEST_ENGINE_LOG(_FMT,...)                     if (g.TestEngineHookItems) ImGuiTestEngineHook_Log(&g, _FMT, __VA_ARGS__)                                                   // Custom log entry from user land into test log
#define IMGUI_TEST_ENGINE_ID_INFO(_ID,_TYPE,_DATA)          if (g.TestEngineHookIdInfo == id) ImGuiTestEngineHook_IdInfo(&g, _TYPE, _ID, (const void*)(_DATA));
#define IMGUI_TEST_ENGINE_ID_INFO2(_ID,_TYPE,_DATA,_DATA2)  if (g.TestEngineHookIdInfo == id) ImGuiTestEngineHook_IdInfo(&g, _TYPE, _ID, (const void*)(_DATA), (const void*)(_DATA2));
#else
#define IMGUI_TEST_ENGINE_ITEM_ADD(_BB,_ID)                 do { } while (0)
#define IMGUI_TEST_ENGINE_ITEM_INFO(_ID,_LABEL,_FLAGS)      do { } while (0)
#define IMGUI_TEST_ENGINE_LOG(_FMT,...)                     do { } while (0)
#define IMGUI_TEST_ENGINE_ID_INFO(_ID,_TYPE,_DATA)          do { } while (0)
#define IMGUI_TEST_ENGINE_ID_INFO2(_ID,_TYPE,_DATA,_DATA2)  do { } while (0)
#endif // #ifdef IMGUI_ENABLE_TEST_ENGINE
//-----------------------------------------------------------------------------

#if defined(__clang__)
#pragma clang diagnostic pop
#else
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif // #if defined(__GNUC__)
#endif // #if defined(__clang__)
#ifdef _MSC_VER
#pragma warning (pop)
#endif // #ifdef _MSC_VER
#endif// #ifndef IMGUI_DISABLE
#ifdef __cplusplus
} // End of extern "C" block
#endif
